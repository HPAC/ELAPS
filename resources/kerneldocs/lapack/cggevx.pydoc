(('cggevx', 'CGGEVX computes for a pair of N-by-N complex nonsymmetric matrices\n(A,B) the generalized eigenvalues, and optionally, the left and/or\nright generalized eigenvectors.\n\nOptionally, it also computes a balancing transformation to improve\nthe conditioning of the eigenvalues and eigenvectors (ILO, IHI,\nLSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for\nthe eigenvalues (RCONDE), and reciprocal condition numbers for the\nright eigenvectors (RCONDV).\n\nA generalized eigenvalue for a pair of matrices (A,B) is a scalar\nlambda or a ratio alpha/beta = lambda, such that A - lambda*B is\nsingular. It is usually represented as the pair (alpha,beta), as\nthere is a reasonable interpretation for beta=0, and even for both\nbeing zero.\n\nThe right eigenvector v(j) corresponding to the eigenvalue lambda(j)\nof (A,B) satisfies\n                 A * v(j) = lambda(j) * B * v(j) .\nThe left eigenvector u(j) corresponding to the eigenvalue lambda(j)\nof (A,B) satisfies\n                 u(j)**H * A  = lambda(j) * u(j)**H * B.\nwhere u(j)**H is the conjugate-transpose of u(j).'), ('BALANC', "BALANC is CHARACTER*1\nSpecifies the balance option to be performed:\n= 'N':  do not diagonally scale or permute;\n= 'P':  permute only;\n= 'S':  scale only;\n= 'B':  both permute and scale.\nComputed reciprocal condition numbers will be for the\nmatrices after permuting and/or balancing. Permuting does\nnot change condition numbers (in exact arithmetic), but\nbalancing does."), ('JOBVL', "JOBVL is CHARACTER*1\n= 'N':  do not compute the left generalized eigenvectors;\n= 'V':  compute the left generalized eigenvectors."), ('JOBVR', "JOBVR is CHARACTER*1\n= 'N':  do not compute the right generalized eigenvectors;\n= 'V':  compute the right generalized eigenvectors."), ('SENSE', "SENSE is CHARACTER*1\nDetermines which reciprocal condition numbers are computed.\n= 'N': none are computed;\n= 'E': computed for eigenvalues only;\n= 'V': computed for eigenvectors only;\n= 'B': computed for eigenvalues and eigenvectors."), ('N', 'N is INTEGER\nThe order of the matrices A, B, VL, and VR.  N >= 0.'), ('A', 'A is COMPLEX array, dimension (LDA, N)\nOn entry, the matrix A in the pair (A,B).\nOn exit, A has been overwritten. If JOBVL=\'V\' or JOBVR=\'V\'\nor both, then A contains the first part of the complex Schur\nform of the "balanced" versions of the input A and B.'), ('LDA', 'LDA is INTEGER\nThe leading dimension of A.  LDA >= max(1,N).'), ('B', 'B is COMPLEX array, dimension (LDB, N)\nOn entry, the matrix B in the pair (A,B).\nOn exit, B has been overwritten. If JOBVL=\'V\' or JOBVR=\'V\'\nor both, then B contains the second part of the complex\nSchur form of the "balanced" versions of the input A and B.'), ('LDB', 'LDB is INTEGER\nThe leading dimension of B.  LDB >= max(1,N).'), ('ALPHA', 'ALPHA is COMPLEX array, dimension (N)'), ('BETA', 'BETA is COMPLEX array, dimension (N)\nOn exit, ALPHA(j)/BETA(j), j=1,...,N, will be the generalized\neigenvalues.\n\nNote: the quotient ALPHA(j)/BETA(j) ) may easily over- or\nunderflow, and BETA(j) may even be zero.  Thus, the user\nshould avoid naively computing the ratio ALPHA/BETA.\nHowever, ALPHA will be always less than and usually\ncomparable with norm(A) in magnitude, and BETA always less\nthan and usually comparable with norm(B).'), ('VL', "VL is COMPLEX array, dimension (LDVL,N)\nIf JOBVL = 'V', the left generalized eigenvectors u(j) are\nstored one after another in the columns of VL, in the same\norder as their eigenvalues.\nEach eigenvector will be scaled so the largest component\nwill have abs(real part) + abs(imag. part) = 1.\nNot referenced if JOBVL = 'N'."), ('LDVL', "LDVL is INTEGER\nThe leading dimension of the matrix VL. LDVL >= 1, and\nif JOBVL = 'V', LDVL >= N."), ('VR', "VR is COMPLEX array, dimension (LDVR,N)\nIf JOBVR = 'V', the right generalized eigenvectors v(j) are\nstored one after another in the columns of VR, in the same\norder as their eigenvalues.\nEach eigenvector will be scaled so the largest component\nwill have abs(real part) + abs(imag. part) = 1.\nNot referenced if JOBVR = 'N'."), ('LDVR', "LDVR is INTEGER\nThe leading dimension of the matrix VR. LDVR >= 1, and\nif JOBVR = 'V', LDVR >= N."), ('ILO', 'ILO is INTEGER'), ('IHI', "IHI is INTEGER\nILO and IHI are integer values such that on exit\nA(i,j) = 0 and B(i,j) = 0 if i > j and\nj = 1,...,ILO-1 or i = IHI+1,...,N.\nIf BALANC = 'N' or 'S', ILO = 1 and IHI = N."), ('LSCALE', 'LSCALE is REAL array, dimension (N)\nDetails of the permutations and scaling factors applied\nto the left side of A and B.  If PL(j) is the index of the\nrow interchanged with row j, and DL(j) is the scaling\nfactor applied to row j, then\n  LSCALE(j) = PL(j)  for j = 1,...,ILO-1\n            = DL(j)  for j = ILO,...,IHI\n            = PL(j)  for j = IHI+1,...,N.\nThe order in which the interchanges are made is N to IHI+1,\nthen 1 to ILO-1.'), ('RSCALE', 'RSCALE is REAL array, dimension (N)\nDetails of the permutations and scaling factors applied\nto the right side of A and B.  If PR(j) is the index of the\ncolumn interchanged with column j, and DR(j) is the scaling\nfactor applied to column j, then\n  RSCALE(j) = PR(j)  for j = 1,...,ILO-1\n            = DR(j)  for j = ILO,...,IHI\n            = PR(j)  for j = IHI+1,...,N\nThe order in which the interchanges are made is N to IHI+1,\nthen 1 to ILO-1.'), ('ABNRM', 'ABNRM is REAL\nThe one-norm of the balanced matrix A.'), ('BBNRM', 'BBNRM is REAL\nThe one-norm of the balanced matrix B.'), ('RCONDE', "RCONDE is REAL array, dimension (N)\nIf SENSE = 'E' or 'B', the reciprocal condition numbers of\nthe eigenvalues, stored in consecutive elements of the array.\nIf SENSE = 'N' or 'V', RCONDE is not referenced."), ('RCONDV', "RCONDV is REAL array, dimension (N)\nIf SENSE = 'V' or 'B', the estimated reciprocal condition\nnumbers of the eigenvectors, stored in consecutive elements\nof the array. If the eigenvalues cannot be reordered to\ncompute RCONDV(j), RCONDV(j) is set to 0; this can only occur\nwhen the true value would be very small anyway. \nIf SENSE = 'N' or 'E', RCONDV is not referenced."), ('WORK', 'WORK is COMPLEX array, dimension (MAX(1,LWORK))\nOn exit, if INFO = 0, WORK(1) returns the optimal LWORK.'), ('LWORK', "LWORK is INTEGER\nThe dimension of the array WORK. LWORK >= max(1,2*N).\nIf SENSE = 'E', LWORK >= max(1,4*N).\nIf SENSE = 'V' or 'B', LWORK >= max(1,2*N*N+2*N).\n\nIf LWORK = -1, then a workspace query is assumed; the routine\nonly calculates the optimal size of the WORK array, returns\nthis value as the first entry of the WORK array, and no error\nmessage related to LWORK is issued by XERBLA."), ('RWORK', "RWORK is REAL array, dimension (lrwork)\nlrwork must be at least max(1,6*N) if BALANC = 'S' or 'B',\nand at least max(1,2*N) otherwise.\nReal workspace."), ('IWORK', "IWORK is INTEGER array, dimension (N+2)\nIf SENSE = 'E', IWORK is not referenced."), ('BWORK', "BWORK is LOGICAL array, dimension (N)\nIf SENSE = 'N', BWORK is not referenced."), ('INFO', 'INFO is INTEGER\n= 0:  successful exit\n< 0:  if INFO = -i, the i-th argument had an illegal value.\n= 1,...,N:\n      The QZ iteration failed.  No eigenvectors have been\n      calculated, but ALPHA(j) and BETA(j) should be correct\n      for j=INFO+1,...,N.\n> N:  =N+1: other than QZ iteration failed in CHGEQZ.\n      =N+2: error return from CTGEVC.'))
