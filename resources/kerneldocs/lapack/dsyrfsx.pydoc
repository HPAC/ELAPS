(('dsyrfsx', 'DSYRFSX improves the computed solution to a system of linear\nequations when the coefficient matrix is symmetric indefinite, and\nprovides error bounds and backward error estimates for the\nsolution.  In addition to normwise error bound, the code provides\nmaximum componentwise error bound if possible.  See comments for\nERR_BNDS_NORM and ERR_BNDS_COMP for details of the error bounds.\n\nThe original system of linear equations may have been equilibrated\nbefore calling this routine, as described by arguments EQUED and S\nbelow. In this case, the solution and error bounds returned are\nfor the original unequilibrated system.'), ('UPLO', "UPLO is CHARACTER*1\nU':  Upper triangle of A is stored;\nL':  Lower triangle of A is stored."), ('EQUED', "EQUED is CHARACTER*1\nfies the form of equilibration that was done to A\ne calling this routine. This is needed to compute\nolution and error bounds correctly.\nN':  No equilibration\nY':  Both row and column equilibration, i.e., A has been\n     replaced by diag(S) * A * diag(S).\n     The right hand side B has been changed accordingly."), ('N', 'N is INTEGER\nrder of the matrix A.  N >= 0.'), ('NRHS', 'NRHS is INTEGER\number of right hand sides, i.e., the number of columns\ne matrices B and X.  NRHS >= 0.'), ('A', "A is DOUBLE PRECISION array, dimension (LDA,N)\nymmetric matrix A.  If UPLO = 'U', the leading N-by-N\n triangular part of A contains the upper triangular\nof the matrix A, and the strictly lower triangular\nof A is not referenced.  If UPLO = 'L', the leading\nN lower triangular part of A contains the lower\ngular part of the matrix A, and the strictly upper\ngular part of A is not referenced."), ('LDA', 'LDA is INTEGER\neading dimension of the array A.  LDA >= max(1,N).'), ('AF', 'AF is DOUBLE PRECISION array, dimension (LDAF,N)\nactored form of the matrix A.  AF contains the block\nnal matrix D and the multipliers used to obtain the\nr U or L from the factorization A = U*D*U**T or A =\n**T as computed by DSYTRF.'), ('LDAF', 'LDAF is INTEGER\neading dimension of the array AF.  LDAF >= max(1,N).'), ('IPIV', 'IPIV is INTEGER array, dimension (N)\nls of the interchanges and the block structure of D\ntermined by DSYTRF.'), ('S', "S is DOUBLE PRECISION array, dimension (N)\ncale factors for A.  If EQUED = 'Y', A is multiplied on\neft and right by diag(S).  S is an input argument if FACT =\notherwise, S is an output argument.  If FACT = 'F' and EQUED\n, each element of S must be positive.  If S is output, each\nnt of S is a power of the radix. If S is input, each element\nshould be a power of the radix to ensure a reliable solution\nrror estimates. Scaling by powers of the radix does not cause\ning errors unless the result underflows or overflows.\ning errors during scaling lead to refining with a matrix that\nt equivalent to the input matrix, producing error estimates\nmay not be reliable."), ('B', 'B is DOUBLE PRECISION array, dimension (LDB,NRHS)\night hand side matrix B.'), ('LDB', 'LDB is INTEGER\neading dimension of the array B.  LDB >= max(1,N).'), ('X', 'X is DOUBLE PRECISION array, dimension (LDX,NRHS)\ntry, the solution matrix X, as computed by DGETRS.\nit, the improved solution matrix X.'), ('LDX', 'LDX is INTEGER\neading dimension of the array X.  LDX >= max(1,N).'), ('RCOND', 'RCOND is DOUBLE PRECISION\nrocal scaled condition number.  This is an estimate of the\nrocal Skeel condition number of the matrix A after\nibration (if done).  If this is less than the machine\nsion (in particular, if it is zero), the matrix is singular\nrking precision.  Note that the error may still be small even\nis number is very small and the matrix appears ill-\ntioned.'), ('BERR', 'BERR is DOUBLE PRECISION array, dimension (NRHS)\nnentwise relative backward error.  This is the\nnentwise relative backward error of each solution vector X(j)\n, the smallest relative change in any element of A or B that\n X(j) an exact solution).'), ('N_ERR_BNDS', 'N_ERR_BNDS is INTEGER\nr of error bounds to return for each right hand side\nach type (normwise or componentwise).  See ERR_BNDS_NORM and\nNDS_COMP below.'), ('ERR_BNDS_NORM', 'ERR_BNDS_NORM is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\nach right-hand side, this array contains information about\nus error bounds and condition numbers corresponding to the\nise relative error, which is defined as follows:\n\nise relative error in the ith solution vector:\n   max_j (abs(XTRUE(j,i) - X(j,i)))\n  ------------------------------\n        max_j abs(X(j,i))\n\nrray is indexed by the type of error information as described\n. There currently are up to three pieces of information\nned.\n\nirst index in ERR_BNDS_NORM(i,:) corresponds to the ith\n-hand side.\n\necond index in ERR_BNDS_NORM(:,err) contains the following\n fields:\n 1 "Trust/don\'t trust" boolean. Trust the answer if the\n    reciprocal condition number is less than the threshold\n    sqrt(n) * dlamch(\'Epsilon\').\n\n 2 "Guaranteed" error bound: The estimated forward error,\n    almost certainly within a factor of 10 of the true error\n    so long as the next entry is greater than the threshold\n    sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n    be trusted if the previous boolean is true.\n\n 3  Reciprocal condition number: Estimated normwise\n    reciprocal condition number.  Compared with the threshold\n    sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n    estimate is "guaranteed". These reciprocal condition\n    numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n    appropriately scaled matrix Z.\n    Let Z = S*A, where S scales each row by a power of the\n    radix so all absolute row sums of Z are approximately 1.\n\napack Working Note 165 for further details and extra\nons.'), ('ERR_BNDS_COMP', 'ERR_BNDS_COMP is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\nach right-hand side, this array contains information about\nus error bounds and condition numbers corresponding to the\nnentwise relative error, which is defined as follows:\n\nnentwise relative error in the ith solution vector:\n          abs(XTRUE(j,i) - X(j,i))\n   max_j ----------------------\n               abs(X(j,i))\n\nrray is indexed by the right-hand side i (on which the\nnentwise relative error depends), and the type of error\nmation as described below. There currently are up to three\ns of information returned for each right-hand side. If\nnentwise accuracy is not requested (PARAMS(3) = 0.0), then\nNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\nirst (:,N_ERR_BNDS) entries are returned.\n\nirst index in ERR_BNDS_COMP(i,:) corresponds to the ith\n-hand side.\n\necond index in ERR_BNDS_COMP(:,err) contains the following\n fields:\n 1 "Trust/don\'t trust" boolean. Trust the answer if the\n    reciprocal condition number is less than the threshold\n    sqrt(n) * dlamch(\'Epsilon\').\n\n 2 "Guaranteed" error bound: The estimated forward error,\n    almost certainly within a factor of 10 of the true error\n    so long as the next entry is greater than the threshold\n    sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n    be trusted if the previous boolean is true.\n\n 3  Reciprocal condition number: Estimated componentwise\n    reciprocal condition number.  Compared with the threshold\n    sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n    estimate is "guaranteed". These reciprocal condition\n    numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n    appropriately scaled matrix Z.\n    Let Z = S*(A*diag(x)), where x is the solution for the\n    current right-hand side and S scales each row of\n    A*diag(x) by a power of the radix so all absolute row\n    sums of Z are approximately 1.\n\napack Working Note 165 for further details and extra\nons.'), ('NPARAMS', 'NPARAMS is INTEGER\nfies the number of parameters set in PARAMS.  If .LE. 0, the\nS array is never referenced and default values are used.'), ('PARAMS', 'PARAMS is DOUBLE PRECISION array, dimension (NPARAMS)\nfies algorithm parameters.  If an entry is .LT. 0.0, then\nentry will be filled with default value used for that\neter.  Only positions up to NPARAMS are accessed; defaults\nsed for higher-numbered parameters.\n\nAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n  refinement or not.\nefault: 1.0D+0\n  = 0.0 : No refinement is performed, and no error bounds are\n          computed.\n  = 1.0 : Use the double-precision refinement algorithm,\n          possibly with doubled-single computations if the\n          compilation environment does not support DOUBLE\n          PRECISION.\n    (other values are reserved for future use)\n\nAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n  computations allowed for refinement.\nefault: 10\nggressive: Set to 100 to permit convergence using approximate\n           factorizations or factorizations other than LU. If\n           the factorization uses a technique other than\n           Gaussian elimination, the guarantees in\n           err_bnds_norm and err_bnds_comp may no longer be\n           trustworthy.\n\nAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n  will attempt to find a solution with small componentwise\n  relative error in the double-precision algorithm.  Positive\n  is true, 0.0 is false.\nefault: 1.0 (attempt componentwise convergence)'), ('WORK', 'WORK is DOUBLE PRECISION array, dimension (4*N)'), ('IWORK', 'IWORK is INTEGER array, dimension (N)'), ('INFO', 'INFO is INTEGER\n:  Successful exit. The solution to every right-hand side is\nuaranteed.\n:  If INFO = -i, the i-th argument had an illegal value\n and <= N:  U(INFO,INFO) is exactly zero.  The factorization\nas been completed, but the factor U is exactly singular, so\nhe solution and error bounds could not be computed. RCOND = 0\ns returned.\n+J: The solution corresponding to the Jth right-hand side is\not guaranteed. The solutions corresponding to other right-\nand sides K with K > J may not be guaranteed as well, but\nnly the first such right-hand side is reported. If a small\nomponentwise error is not requested (PARAMS(3) = 0.0) then\nhe Jth right-hand side is the first with a normwise error\nound that is not guaranteed (the smallest J such\nhat ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\nhe Jth right-hand side is the first with either a normwise or\nomponentwise error bound that is not guaranteed (the smallest\n such that either ERR_BNDS_NORM(J,1) = 0.0 or\nRR_BNDS_COMP(J,1) = 0.0). See the definition of\nRR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\nbout all of the right-hand sides check ERR_BNDS_NORM or\nRR_BNDS_COMP.'))
