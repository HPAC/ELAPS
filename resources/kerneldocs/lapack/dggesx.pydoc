(('dggesx', 'DGGESX computes for a pair of N-by-N real nonsymmetric matrices\n(A,B), the generalized eigenvalues, the real Schur form (S,T), and,\noptionally, the left and/or right matrices of Schur vectors (VSL and\nVSR).  This gives the generalized Schur factorization\n\n     (A,B) = ( (VSL) S (VSR)**T, (VSL) T (VSR)**T )\n\nOptionally, it also orders the eigenvalues so that a selected cluster\nof eigenvalues appears in the leading diagonal blocks of the upper\nquasi-triangular matrix S and the upper triangular matrix T; computes\na reciprocal condition number for the average of the selected\neigenvalues (RCONDE); and computes a reciprocal condition number for\nthe right and left deflating subspaces corresponding to the selected\neigenvalues (RCONDV). The leading columns of VSL and VSR then form\nan orthonormal basis for the corresponding left and right eigenspaces\n(deflating subspaces).\n\nA generalized eigenvalue for a pair of matrices (A,B) is a scalar w\nor a ratio alpha/beta = w, such that  A - w*B is singular.  It is\nusually represented as the pair (alpha,beta), as there is a\nreasonable interpretation for beta=0 or for both being zero.\n\nA pair of matrices (S,T) is in generalized real Schur form if T is\nupper triangular with non-negative diagonal and S is block upper\ntriangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond\nto real generalized eigenvalues, while 2-by-2 blocks of S will be\n"standardized" by making the corresponding elements of T have the\nform:\n        [  a  0  ]\n        [  0  b  ]\n\nand the pair of corresponding 2-by-2 blocks in S and T will have a\ncomplex conjugate pair of generalized eigenvalues.'), ('JOBVSL', "JOBVSL is CHARACTER*1\n= 'N':  do not compute the left Schur vectors;\n= 'V':  compute the left Schur vectors."), ('JOBVSR', "JOBVSR is CHARACTER*1\n= 'N':  do not compute the right Schur vectors;\n= 'V':  compute the right Schur vectors."), ('SORT', "SORT is CHARACTER*1\nSpecifies whether or not to order the eigenvalues on the\ndiagonal of the generalized Schur form.\n= 'N':  Eigenvalues are not ordered;\n= 'S':  Eigenvalues are ordered (see SELCTG)."), ('SELCTG', "SELCTG is procedure) LOGICAL FUNCTION of three DOUBLE PRECISION arguments\nSELCTG must be declared EXTERNAL in the calling subroutine.\nIf SORT = 'N', SELCTG is not referenced.\nIf SORT = 'S', SELCTG is used to select eigenvalues to sort\nto the top left of the Schur form.\nAn eigenvalue (ALPHAR(j)+ALPHAI(j))/BETA(j) is selected if\nSELCTG(ALPHAR(j),ALPHAI(j),BETA(j)) is true; i.e. if either\none of a complex conjugate pair of eigenvalues is selected,\nthen both complex eigenvalues are selected.\nNote that a selected complex eigenvalue may no longer satisfy\nSELCTG(ALPHAR(j),ALPHAI(j),BETA(j)) = .TRUE. after ordering,\nsince ordering may change the value of complex eigenvalues\n(especially if the eigenvalue is ill-conditioned), in this\ncase INFO is set to N+3."), ('SENSE', "SENSE is CHARACTER*1\nDetermines which reciprocal condition numbers are computed.\n= 'N' : None are computed;\n= 'E' : Computed for average of selected eigenvalues only;\n= 'V' : Computed for selected deflating subspaces only;\n= 'B' : Computed for both.\nIf SENSE = 'E', 'V', or 'B', SORT must equal 'S'."), ('N', 'N is INTEGER\nThe order of the matrices A, B, VSL, and VSR.  N >= 0.'), ('A', 'A is DOUBLE PRECISION array, dimension (LDA, N)\nOn entry, the first of the pair of matrices.\nOn exit, A has been overwritten by its generalized Schur\nform S.'), ('LDA', 'LDA is INTEGER\nThe leading dimension of A.  LDA >= max(1,N).'), ('B', 'B is DOUBLE PRECISION array, dimension (LDB, N)\nOn entry, the second of the pair of matrices.\nOn exit, B has been overwritten by its generalized Schur\nform T.'), ('LDB', 'LDB is INTEGER\nThe leading dimension of B.  LDB >= max(1,N).'), ('SDIM', "SDIM is INTEGER\nIf SORT = 'N', SDIM = 0.\nIf SORT = 'S', SDIM = number of eigenvalues (after sorting)\nfor which SELCTG is true.  (Complex conjugate pairs for which\nSELCTG is true for either eigenvalue count as 2.)"), ('ALPHAR', 'ALPHAR is DOUBLE PRECISION array, dimension (N)'), ('ALPHAI', 'ALPHAI is DOUBLE PRECISION array, dimension (N)'), ('BETA', 'BETA is DOUBLE PRECISION array, dimension (N)\nOn exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will\nbe the generalized eigenvalues.  ALPHAR(j) + ALPHAI(j)*i\nand BETA(j),j=1,...,N  are the diagonals of the complex Schur\nform (S,T) that would result if the 2-by-2 diagonal blocks of\nthe real Schur form of (A,B) were further reduced to\ntriangular form using 2-by-2 complex unitary transformations.\nIf ALPHAI(j) is zero, then the j-th eigenvalue is real; if\npositive, then the j-th and (j+1)-st eigenvalues are a\ncomplex conjugate pair, with ALPHAI(j+1) negative.\n\nNote: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)\nmay easily over- or underflow, and BETA(j) may even be zero.\nThus, the user should avoid naively computing the ratio.\nHowever, ALPHAR and ALPHAI will be always less than and\nusually comparable with norm(A) in magnitude, and BETA always\nless than and usually comparable with norm(B).'), ('VSL', "VSL is DOUBLE PRECISION array, dimension (LDVSL,N)\nIf JOBVSL = 'V', VSL will contain the left Schur vectors.\nNot referenced if JOBVSL = 'N'."), ('LDVSL', "LDVSL is INTEGER\nThe leading dimension of the matrix VSL. LDVSL >=1, and\nif JOBVSL = 'V', LDVSL >= N."), ('VSR', "VSR is DOUBLE PRECISION array, dimension (LDVSR,N)\nIf JOBVSR = 'V', VSR will contain the right Schur vectors.\nNot referenced if JOBVSR = 'N'."), ('LDVSR', "LDVSR is INTEGER\nThe leading dimension of the matrix VSR. LDVSR >= 1, and\nif JOBVSR = 'V', LDVSR >= N."), ('RCONDE', "RCONDE is DOUBLE PRECISION array, dimension ( 2 )\nIf SENSE = 'E' or 'B', RCONDE(1) and RCONDE(2) contain the\nreciprocal condition numbers for the average of the selected\neigenvalues.\nNot referenced if SENSE = 'N' or 'V'."), ('RCONDV', "RCONDV is DOUBLE PRECISION array, dimension ( 2 )\nIf SENSE = 'V' or 'B', RCONDV(1) and RCONDV(2) contain the\nreciprocal condition numbers for the selected deflating\nsubspaces.\nNot referenced if SENSE = 'N' or 'E'."), ('WORK', 'WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))\nOn exit, if INFO = 0, WORK(1) returns the optimal LWORK.'), ('LWORK', "LWORK is INTEGER\nThe dimension of the array WORK.\nIf N = 0, LWORK >= 1, else if SENSE = 'E', 'V', or 'B',\nLWORK >= max( 8*N, 6*N+16, 2*SDIM*(N-SDIM) ), else\nLWORK >= max( 8*N, 6*N+16 ).\nNote that 2*SDIM*(N-SDIM) <= N*N/2.\nNote also that an error is only returned if\nLWORK < max( 8*N, 6*N+16), but if SENSE = 'E' or 'V' or 'B'\nthis may not be large enough.\n\nIf LWORK = -1, then a workspace query is assumed; the routine\nonly calculates the bound on the optimal size of the WORK\narray and the minimum size of the IWORK array, returns these\nvalues as the first entries of the WORK and IWORK arrays, and\nno error message related to LWORK or LIWORK is issued by\nXERBLA."), ('IWORK', 'IWORK is INTEGER array, dimension (MAX(1,LIWORK))\nOn exit, if INFO = 0, IWORK(1) returns the minimum LIWORK.'), ('LIWORK', "LIWORK is INTEGER\nThe dimension of the array IWORK.\nIf SENSE = 'N' or N = 0, LIWORK >= 1, otherwise\nLIWORK >= N+6.\n\nIf LIWORK = -1, then a workspace query is assumed; the\nroutine only calculates the bound on the optimal size of the\nWORK array and the minimum size of the IWORK array, returns\nthese values as the first entries of the WORK and IWORK\narrays, and no error message related to LWORK or LIWORK is\nissued by XERBLA."), ('BWORK', "BWORK is LOGICAL array, dimension (N)\nNot referenced if SORT = 'N'."), ('INFO', 'INFO is INTEGER\n= 0:  successful exit\n< 0:  if INFO = -i, the i-th argument had an illegal value.\n= 1,...,N:\n      The QZ iteration failed.  (A,B) are not in Schur\n      form, but ALPHAR(j), ALPHAI(j), and BETA(j) should\n      be correct for j=INFO+1,...,N.\n> N:  =N+1: other than QZ iteration failed in DHGEQZ\n      =N+2: after reordering, roundoff changed values of\n            some complex eigenvalues so that leading\n            eigenvalues in the Generalized Schur form no\n            longer satisfy SELCTG=.TRUE.  This could also\n            be caused due to scaling.\n      =N+3: reordering failed in DTGSEN.'))
