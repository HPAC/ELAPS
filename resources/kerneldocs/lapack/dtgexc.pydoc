(('dtgexc', 'DTGEXC reorders the generalized real Schur decomposition of a real\nmatrix pair (A,B) using an orthogonal equivalence transformation\n\n               (A, B) = Q * (A, B) * Z**T,\n\nso that the diagonal block of (A, B) with row index IFST is moved\nto row ILST.\n\n(A, B) must be in generalized real Schur canonical form (as returned\nby DGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2\ndiagonal blocks. B is upper triangular.\n\nOptionally, the matrices Q and Z of generalized Schur vectors are\nupdated.\n\n       Q(in) * A(in) * Z(in)**T = Q(out) * A(out) * Z(out)**T\n       Q(in) * B(in) * Z(in)**T = Q(out) * B(out) * Z(out)**T'), ('WANTQ', 'WANTQ is LOGICAL\n.TRUE. : update the left transformation matrix Q;\n.FALSE.: do not update Q.'), ('WANTZ', 'WANTZ is LOGICAL\n.TRUE. : update the right transformation matrix Z;\n.FALSE.: do not update Z.'), ('N', 'N is INTEGER\nThe order of the matrices A and B. N >= 0.'), ('A', 'A is DOUBLE PRECISION array, dimension (LDA,N)\nOn entry, the matrix A in generalized real Schur canonical\nform.\nOn exit, the updated matrix A, again in generalized\nreal Schur canonical form.'), ('LDA', 'LDA is INTEGER\nThe leading dimension of the array A. LDA >= max(1,N).'), ('B', 'B is DOUBLE PRECISION array, dimension (LDB,N)\nOn entry, the matrix B in generalized real Schur canonical\nform (A,B).\nOn exit, the updated matrix B, again in generalized\nreal Schur canonical form (A,B).'), ('LDB', 'LDB is INTEGER\nThe leading dimension of the array B. LDB >= max(1,N).'), ('Q', 'Q is DOUBLE PRECISION array, dimension (LDQ,N)\nOn entry, if WANTQ = .TRUE., the orthogonal matrix Q.\nOn exit, the updated matrix Q.\nIf WANTQ = .FALSE., Q is not referenced.'), ('LDQ', 'LDQ is INTEGER\nThe leading dimension of the array Q. LDQ >= 1.\nIf WANTQ = .TRUE., LDQ >= N.'), ('Z', 'Z is DOUBLE PRECISION array, dimension (LDZ,N)\nOn entry, if WANTZ = .TRUE., the orthogonal matrix Z.\nOn exit, the updated matrix Z.\nIf WANTZ = .FALSE., Z is not referenced.'), ('LDZ', 'LDZ is INTEGER\nThe leading dimension of the array Z. LDZ >= 1.\nIf WANTZ = .TRUE., LDZ >= N.'), ('IFST', 'IFST is INTEGER'), ('ILST', 'ILST is INTEGER\nSpecify the reordering of the diagonal blocks of (A, B).\nThe block with row index IFST is moved to row ILST, by a\nsequence of swapping between adjacent blocks.\nOn exit, if IFST pointed on entry to the second row of\na 2-by-2 block, it is changed to point to the first row;\nILST always points to the first row of the block in its\nfinal position (which may differ from its input value by\n+1 or -1). 1 <= IFST, ILST <= N.'), ('WORK', 'WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))\nOn exit, if INFO = 0, WORK(1) returns the optimal LWORK.'), ('LWORK', 'LWORK is INTEGER\nThe dimension of the array WORK.\nLWORK >= 1 when N <= 1, otherwise LWORK >= 4*N + 16.\n\nIf LWORK = -1, then a workspace query is assumed; the routine\nonly calculates the optimal size of the WORK array, returns\nthis value as the first entry of the WORK array, and no error\nmessage related to LWORK is issued by XERBLA.'), ('INFO', 'INFO is INTEGER\n =0:  successful exit.\n <0:  if INFO = -i, the i-th argument had an illegal value.\n =1:  The transformed matrix pair (A, B) would be too far\n      from generalized Schur form; the problem is ill-\n      conditioned. (A, B) may have been partially reordered,\n      and ILST points to the first row of the current\n      position of the block being moved.'))
