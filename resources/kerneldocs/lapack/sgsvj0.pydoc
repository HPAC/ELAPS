(('sgsvj0', 'SGSVJ0 is called from SGESVJ as a pre-processor and that is its main\npurpose. It applies Jacobi rotations in the same way as SGESVJ does, but\nit does not check convergence (stopping criterion). Few tuning\nparameters (marked by [TP]) are available for the implementer.'), ('JOBV', "JOBV is CHARACTER*1\nSpecifies whether the output from this procedure is used\nto compute the matrix V:\n= 'V': the product of the Jacobi rotations is accumulated\n       by postmulyiplying the N-by-N array V.\n      (See the description of V.)\n= 'A': the product of the Jacobi rotations is accumulated\n       by postmulyiplying the MV-by-N array V.\n      (See the descriptions of MV and V.)\n= 'N': the Jacobi rotations are not accumulated."), ('M', 'M is INTEGER\nThe number of rows of the input matrix A.  M >= 0.'), ('N', 'N is INTEGER\nThe number of columns of the input matrix A.\nM >= N >= 0.'), ('A', 'A is REAL array, dimension (LDA,N)\nOn entry, M-by-N matrix A, such that A*diag(D) represents\nthe input matrix.\nOn exit,\nA_onexit * D_onexit represents the input matrix A*diag(D)\npost-multiplied by a sequence of Jacobi rotations, where the\nrotation threshold and the total number of sweeps are given in\nTOL and NSWEEP, respectively.\n(See the descriptions of D, TOL and NSWEEP.)'), ('LDA', 'LDA is INTEGER\nThe leading dimension of the array A.  LDA >= max(1,M).'), ('D', 'D is REAL array, dimension (N)\nThe array D accumulates the scaling factors from the fast scaled\nJacobi rotations.\nOn entry, A*diag(D) represents the input matrix.\nOn exit, A_onexit*diag(D_onexit) represents the input matrix\npost-multiplied by a sequence of Jacobi rotations, where the\nrotation threshold and the total number of sweeps are given in\nTOL and NSWEEP, respectively.\n(See the descriptions of A, TOL and NSWEEP.)'), ('SVA', 'SVA is REAL array, dimension (N)\nOn entry, SVA contains the Euclidean norms of the columns of\nthe matrix A*diag(D).\nOn exit, SVA contains the Euclidean norms of the columns of\nthe matrix onexit*diag(D_onexit).'), ('MV', "MV is INTEGER\nIf JOBV .EQ. 'A', then MV rows of V are post-multipled by a\n                 sequence of Jacobi rotations.\nIf JOBV = 'N',   then MV is not referenced."), ('V', "V is REAL array, dimension (LDV,N)\nIf JOBV .EQ. 'V' then N rows of V are post-multipled by a\n                 sequence of Jacobi rotations.\nIf JOBV .EQ. 'A' then MV rows of V are post-multipled by a\n                 sequence of Jacobi rotations.\nIf JOBV = 'N',   then V is not referenced."), ('LDV', "LDV is INTEGER\nThe leading dimension of the array V,  LDV >= 1.\nIf JOBV = 'V', LDV .GE. N.\nIf JOBV = 'A', LDV .GE. MV."), ('EPS', "EPS is REAL\nEPS = SLAMCH('Epsilon')"), ('SFMIN', "SFMIN is REAL\nSFMIN = SLAMCH('Safe Minimum')"), ('TOL', 'TOL is REAL\nTOL is the threshold for Jacobi rotations. For a pair\nA(:,p), A(:,q) of pivot columns, the Jacobi rotation is\napplied only if ABS(COS(angle(A(:,p),A(:,q)))) .GT. TOL.'), ('NSWEEP', 'NSWEEP is INTEGER\nNSWEEP is the number of sweeps of Jacobi rotations to be\nperformed.'), ('WORK', 'WORK is REAL array, dimension LWORK.'), ('LWORK', 'LWORK is INTEGER\nLWORK is the dimension of WORK. LWORK .GE. M.'), ('INFO', 'INFO is INTEGER\n= 0 : successful exit.\n< 0 : if INFO = -i, then the i-th argument had an illegal value'))
