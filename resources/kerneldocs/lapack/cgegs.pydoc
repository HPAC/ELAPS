(('cgegs', 'This routine is deprecated and has been replaced by routine CGGES.\n\nCGEGS computes the eigenvalues, Schur form, and, optionally, the\nleft and or/right Schur vectors of a complex matrix pair (A,B).\nGiven two square matrices A and B, the generalized Schur\nfactorization has the form\n\n   A = Q*S*Z**H,  B = Q*T*Z**H\n\nwhere Q and Z are unitary matrices and S and T are upper triangular.\nThe columns of Q are the left Schur vectors\nand the columns of Z are the right Schur vectors.\n\nIf only the eigenvalues of (A,B) are needed, the driver routine\nCGEGV should be used instead.  See CGEGV for a description of the\neigenvalues of the generalized nonsymmetric eigenvalue problem\n(GNEP).'), ('JOBVSL', "JOBVSL is CHARACTER*1\n= 'N':  do not compute the left Schur vectors;\n= 'V':  compute the left Schur vectors (returned in VSL)."), ('JOBVSR', "JOBVSR is CHARACTER*1\n= 'N':  do not compute the right Schur vectors;\n= 'V':  compute the right Schur vectors (returned in VSR)."), ('N', 'N is INTEGER\nThe order of the matrices A, B, VSL, and VSR.  N >= 0.'), ('A', 'A is COMPLEX array, dimension (LDA, N)\nOn entry, the matrix A.\nOn exit, the upper triangular matrix S from the generalized\nSchur factorization.'), ('LDA', 'LDA is INTEGER\nThe leading dimension of A.  LDA >= max(1,N).'), ('B', 'B is COMPLEX array, dimension (LDB, N)\nOn entry, the matrix B.\nOn exit, the upper triangular matrix T from the generalized\nSchur factorization.'), ('LDB', 'LDB is INTEGER\nThe leading dimension of B.  LDB >= max(1,N).'), ('ALPHA', 'ALPHA is COMPLEX array, dimension (N)\nThe complex scalars alpha that define the eigenvalues of\nGNEP.  ALPHA(j) = S(j,j), the diagonal element of the Schur\nform of A.'), ('BETA', 'BETA is COMPLEX array, dimension (N)\nThe non-negative real scalars beta that define the\neigenvalues of GNEP.  BETA(j) = T(j,j), the diagonal element\nof the triangular factor T.\n\nTogether, the quantities alpha = ALPHA(j) and beta = BETA(j)\nrepresent the j-th eigenvalue of the matrix pair (A,B), in\none of the forms lambda = alpha/beta or mu = beta/alpha.\nSince either lambda or mu may overflow, they should not,\nin general, be computed.'), ('VSL', "VSL is COMPLEX array, dimension (LDVSL,N)\nIf JOBVSL = 'V', the matrix of left Schur vectors Q.\nNot referenced if JOBVSL = 'N'."), ('LDVSL', "LDVSL is INTEGER\nThe leading dimension of the matrix VSL. LDVSL >= 1, and\nif JOBVSL = 'V', LDVSL >= N."), ('VSR', "VSR is COMPLEX array, dimension (LDVSR,N)\nIf JOBVSR = 'V', the matrix of right Schur vectors Z.\nNot referenced if JOBVSR = 'N'."), ('LDVSR', "LDVSR is INTEGER\nThe leading dimension of the matrix VSR. LDVSR >= 1, and\nif JOBVSR = 'V', LDVSR >= N."), ('WORK', 'WORK is COMPLEX array, dimension (MAX(1,LWORK))\nOn exit, if INFO = 0, WORK(1) returns the optimal LWORK.'), ('LWORK', 'LWORK is INTEGER\nThe dimension of the array WORK.  LWORK >= max(1,2*N).\nFor good performance, LWORK must generally be larger.\nTo compute the optimal value of LWORK, call ILAENV to get\nblocksizes (for CGEQRF, CUNMQR, and CUNGQR.)  Then compute:\nNB  -- MAX of the blocksizes for CGEQRF, CUNMQR, and CUNGQR;\nthe optimal LWORK is N*(NB+1).\n\nIf LWORK = -1, then a workspace query is assumed; the routine\nonly calculates the optimal size of the WORK array, returns\nthis value as the first entry of the WORK array, and no error\nmessage related to LWORK is issued by XERBLA.'), ('RWORK', 'RWORK is REAL array, dimension (3*N)'), ('INFO', 'INFO is INTEGER\n= 0:  successful exit\n< 0:  if INFO = -i, the i-th argument had an illegal value.\n=1,...,N:\n      The QZ iteration failed.  (A,B) are not in Schur\n      form, but ALPHA(j) and BETA(j) should be correct for\n      j=INFO+1,...,N.\n> N:  errors that usually indicate LAPACK problems:\n      =N+1: error return from CGGBAL\n      =N+2: error return from CGEQRF\n      =N+3: error return from CUNMQR\n      =N+4: error return from CUNGQR\n      =N+5: error return from CGGHRD\n      =N+6: error return from CHGEQZ (other than failed\n                                     iteration)\n      =N+7: error return from CGGBAK (computing VSL)\n      =N+8: error return from CGGBAK (computing VSR)\n      =N+9: error return from CLASCL (various places)'))
