(('dtgsja', "DTGSJA computes the generalized singular value decomposition (GSVD)\nof two real upper triangular (or trapezoidal) matrices A and B.\n\nOn entry, it is assumed that matrices A and B have the following\nforms, which may be obtained by the preprocessing subroutine DGGSVP\nfrom a general M-by-N matrix A and P-by-N matrix B:\n\n             N-K-L  K    L\n   A =    K ( 0    A12  A13 ) if M-K-L >= 0;\n          L ( 0     0   A23 )\n      M-K-L ( 0     0    0  )\n\n           N-K-L  K    L\n   A =  K ( 0    A12  A13 ) if M-K-L < 0;\n      M-K ( 0     0   A23 )\n\n           N-K-L  K    L\n   B =  L ( 0     0   B13 )\n      P-L ( 0     0    0  )\n\nwhere the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular\nupper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,\notherwise A23 is (M-K)-by-L upper trapezoidal.\n\nOn exit,\n\n       U**T *A*Q = D1*( 0 R ),    V**T *B*Q = D2*( 0 R ),\n\nwhere U, V and Q are orthogonal matrices.\nR is a nonsingular upper triangular matrix, and D1 and D2 are\n``diagonal'' matrices, which are of the following structures:\n\nIf M-K-L >= 0,\n\n                    K  L\n       D1 =     K ( I  0 )\n                L ( 0  C )\n            M-K-L ( 0  0 )\n\n                  K  L\n       D2 = L   ( 0  S )\n            P-L ( 0  0 )\n\n               N-K-L  K    L\n  ( 0 R ) = K (  0   R11  R12 ) K\n            L (  0    0   R22 ) L\n\nwhere\n\n  C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),\n  S = diag( BETA(K+1),  ... , BETA(K+L) ),\n  C**2 + S**2 = I.\n\n  R is stored in A(1:K+L,N-K-L+1:N) on exit.\n\nIf M-K-L < 0,\n\n               K M-K K+L-M\n    D1 =   K ( I  0    0   )\n         M-K ( 0  C    0   )\n\n                 K M-K K+L-M\n    D2 =   M-K ( 0  S    0   )\n         K+L-M ( 0  0    I   )\n           P-L ( 0  0    0   )\n\n               N-K-L  K   M-K  K+L-M\n( 0 R ) =    K ( 0    R11  R12  R13  )\n          M-K ( 0     0   R22  R23  )\n        K+L-M ( 0     0    0   R33  )\n\nwhere\nC = diag( ALPHA(K+1), ... , ALPHA(M) ),\nS = diag( BETA(K+1),  ... , BETA(M) ),\nC**2 + S**2 = I.\n\nR = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored\n    (  0  R22 R23 )\nin B(M-K+1:L,N+M-K-L+1:N) on exit.\n\nThe computation of the orthogonal transformation matrices U, V or Q\nis optional.  These matrices may either be formed explicitly, or they\nmay be postmultiplied into input matrices U1, V1, or Q1."), ('JOBU', "JOBU is CHARACTER*1\n= 'U':  U must contain an orthogonal matrix U1 on entry, and\n        the product U1*U is returned;\n= 'I':  U is initialized to the unit matrix, and the\n        orthogonal matrix U is returned;\n= 'N':  U is not computed."), ('JOBV', "JOBV is CHARACTER*1\n= 'V':  V must contain an orthogonal matrix V1 on entry, and\n        the product V1*V is returned;\n= 'I':  V is initialized to the unit matrix, and the\n        orthogonal matrix V is returned;\n= 'N':  V is not computed."), ('JOBQ', "JOBQ is CHARACTER*1\n= 'Q':  Q must contain an orthogonal matrix Q1 on entry, and\n        the product Q1*Q is returned;\n= 'I':  Q is initialized to the unit matrix, and the\n        orthogonal matrix Q is returned;\n= 'N':  Q is not computed."), ('M', 'M is INTEGER\nThe number of rows of the matrix A.  M >= 0.'), ('P', 'P is INTEGER\nThe number of rows of the matrix B.  P >= 0.'), ('N', 'N is INTEGER\nThe number of columns of the matrices A and B.  N >= 0.'), ('K', 'K is INTEGER'), ('L', 'L is INTEGER\n\nK and L specify the subblocks in the input matrices A and B:\nA23 = A(K+1:MIN(K+L,M),N-L+1:N) and B13 = B(1:L,N-L+1:N)\nof A and B, whose GSVD is going to be computed by DTGSJA.\nSee Further Details.'), ('A', 'A is DOUBLE PRECISION array, dimension (LDA,N)\nOn entry, the M-by-N matrix A.\nOn exit, A(N-K+1:N,1:MIN(K+L,M) ) contains the triangular\nmatrix R or part of R.  See Purpose for details.'), ('LDA', 'LDA is INTEGER\nThe leading dimension of the array A. LDA >= max(1,M).'), ('B', 'B is DOUBLE PRECISION array, dimension (LDB,N)\nOn entry, the P-by-N matrix B.\nOn exit, if necessary, B(M-K+1:L,N+M-K-L+1:N) contains\na part of R.  See Purpose for details.'), ('LDB', 'LDB is INTEGER\nThe leading dimension of the array B. LDB >= max(1,P).'), ('TOLA', 'TOLA is DOUBLE PRECISION'), ('TOLB', 'TOLB is DOUBLE PRECISION\n\nTOLA and TOLB are the convergence criteria for the Jacobi-\nKogbetliantz iteration procedure. Generally, they are the\nsame as used in the preprocessing step, say\n    TOLA = max(M,N)*norm(A)*MAZHEPS,\n    TOLB = max(P,N)*norm(B)*MAZHEPS.'), ('ALPHA', 'ALPHA is DOUBLE PRECISION array, dimension (N)'), ('BETA', 'BETA is DOUBLE PRECISION array, dimension (N)\n\nOn exit, ALPHA and BETA contain the generalized singular\nvalue pairs of A and B;\n  ALPHA(1:K) = 1,\n  BETA(1:K)  = 0,\nand if M-K-L >= 0,\n  ALPHA(K+1:K+L) = diag(C),\n  BETA(K+1:K+L)  = diag(S),\nor if M-K-L < 0,\n  ALPHA(K+1:M)= C, ALPHA(M+1:K+L)= 0\n  BETA(K+1:M) = S, BETA(M+1:K+L) = 1.\nFurthermore, if K+L < N,\n  ALPHA(K+L+1:N) = 0 and\n  BETA(K+L+1:N)  = 0.'), ('U', "U is DOUBLE PRECISION array, dimension (LDU,M)\nOn entry, if JOBU = 'U', U must contain a matrix U1 (usually\nthe orthogonal matrix returned by DGGSVP).\nOn exit,\nif JOBU = 'I', U contains the orthogonal matrix U;\nif JOBU = 'U', U contains the product U1*U.\nIf JOBU = 'N', U is not referenced."), ('LDU', "LDU is INTEGER\nThe leading dimension of the array U. LDU >= max(1,M) if\nJOBU = 'U'; LDU >= 1 otherwise."), ('V', "V is DOUBLE PRECISION array, dimension (LDV,P)\nOn entry, if JOBV = 'V', V must contain a matrix V1 (usually\nthe orthogonal matrix returned by DGGSVP).\nOn exit,\nif JOBV = 'I', V contains the orthogonal matrix V;\nif JOBV = 'V', V contains the product V1*V.\nIf JOBV = 'N', V is not referenced."), ('LDV', "LDV is INTEGER\nThe leading dimension of the array V. LDV >= max(1,P) if\nJOBV = 'V'; LDV >= 1 otherwise."), ('Q', "Q is DOUBLE PRECISION array, dimension (LDQ,N)\nOn entry, if JOBQ = 'Q', Q must contain a matrix Q1 (usually\nthe orthogonal matrix returned by DGGSVP).\nOn exit,\nif JOBQ = 'I', Q contains the orthogonal matrix Q;\nif JOBQ = 'Q', Q contains the product Q1*Q.\nIf JOBQ = 'N', Q is not referenced."), ('LDQ', "LDQ is INTEGER\nThe leading dimension of the array Q. LDQ >= max(1,N) if\nJOBQ = 'Q'; LDQ >= 1 otherwise."), ('WORK', 'WORK is DOUBLE PRECISION array, dimension (2*N)'), ('NCYCLE', 'NCYCLE is INTEGER\nThe number of cycles required for convergence.'), ('INFO', 'INFO is INTEGER\n= 0:  successful exit\n< 0:  if INFO = -i, the i-th argument had an illegal value.\n= 1:  the procedure does not converge after MAXIT cycles.'))
