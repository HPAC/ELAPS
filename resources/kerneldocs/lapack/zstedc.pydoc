(('zstedc', 'ZSTEDC computes all eigenvalues and, optionally, eigenvectors of a\nsymmetric tridiagonal matrix using the divide and conquer method.\nThe eigenvectors of a full or band complex Hermitian matrix can also\nbe found if ZHETRD or ZHPTRD or ZHBTRD has been used to reduce this\nmatrix to tridiagonal form.\n\nThis code makes very mild assumptions about floating point\narithmetic. It will work on machines with a guard digit in\nadd/subtract, or on those binary machines without guard digits\nwhich subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.\nIt could conceivably fail on hexadecimal or decimal machines\nwithout guard digits, but we know of none.  See DLAED3 for details.'), ('COMPZ', "COMPZ is CHARACTER*1\n= 'N':  Compute eigenvalues only.\n= 'I':  Compute eigenvectors of tridiagonal matrix also.\n= 'V':  Compute eigenvectors of original Hermitian matrix\n        also.  On entry, Z contains the unitary matrix used\n        to reduce the original matrix to tridiagonal form."), ('N', 'N is INTEGER\nThe dimension of the symmetric tridiagonal matrix.  N >= 0.'), ('D', 'D is DOUBLE PRECISION array, dimension (N)\nOn entry, the diagonal elements of the tridiagonal matrix.\nOn exit, if INFO = 0, the eigenvalues in ascending order.'), ('E', 'E is DOUBLE PRECISION array, dimension (N-1)\nOn entry, the subdiagonal elements of the tridiagonal matrix.\nOn exit, E has been destroyed.'), ('Z', "Z is COMPLEX*16 array, dimension (LDZ,N)\nOn entry, if COMPZ = 'V', then Z contains the unitary\nmatrix used in the reduction to tridiagonal form.\nOn exit, if INFO = 0, then if COMPZ = 'V', Z contains the\northonormal eigenvectors of the original Hermitian matrix,\nand if COMPZ = 'I', Z contains the orthonormal eigenvectors\nof the symmetric tridiagonal matrix.\nIf  COMPZ = 'N', then Z is not referenced."), ('LDZ', 'LDZ is INTEGER\nThe leading dimension of the array Z.  LDZ >= 1.\nIf eigenvectors are desired, then LDZ >= max(1,N).'), ('WORK', 'WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))\nOn exit, if INFO = 0, WORK(1) returns the optimal LWORK.'), ('LWORK', "LWORK is INTEGER\nThe dimension of the array WORK.\nIf COMPZ = 'N' or 'I', or N <= 1, LWORK must be at least 1.\nIf COMPZ = 'V' and N > 1, LWORK must be at least N*N.\nNote that for COMPZ = 'V', then if N is less than or\nequal to the minimum divide size, usually 25, then LWORK need\nonly be 1.\n\nIf LWORK = -1, then a workspace query is assumed; the routine\nonly calculates the optimal sizes of the WORK, RWORK and\nIWORK arrays, returns these values as the first entries of\nthe WORK, RWORK and IWORK arrays, and no error message\nrelated to LWORK or LRWORK or LIWORK is issued by XERBLA."), ('RWORK', 'RWORK is DOUBLE PRECISION array,\n                               dimension (LRWORK)\nOn exit, if INFO = 0, RWORK(1) returns the optimal LRWORK.'), ('LRWORK', "LRWORK is INTEGER\nThe dimension of the array RWORK.\nIf COMPZ = 'N' or N <= 1, LRWORK must be at least 1.\nIf COMPZ = 'V' and N > 1, LRWORK must be at least\n               1 + 3*N + 2*N*lg N + 4*N**2 ,\n               where lg( N ) = smallest integer k such\n               that 2**k >= N.\nIf COMPZ = 'I' and N > 1, LRWORK must be at least\n               1 + 4*N + 2*N**2 .\nNote that for COMPZ = 'I' or 'V', then if N is less than or\nequal to the minimum divide size, usually 25, then LRWORK\nneed only be max(1,2*(N-1)).\n\nIf LRWORK = -1, then a workspace query is assumed; the\nroutine only calculates the optimal sizes of the WORK, RWORK\nand IWORK arrays, returns these values as the first entries\nof the WORK, RWORK and IWORK arrays, and no error message\nrelated to LWORK or LRWORK or LIWORK is issued by XERBLA."), ('IWORK', 'IWORK is INTEGER array, dimension (MAX(1,LIWORK))\nOn exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.'), ('LIWORK', "LIWORK is INTEGER\nThe dimension of the array IWORK.\nIf COMPZ = 'N' or N <= 1, LIWORK must be at least 1.\nIf COMPZ = 'V' or N > 1,  LIWORK must be at least\n                          6 + 6*N + 5*N*lg N.\nIf COMPZ = 'I' or N > 1,  LIWORK must be at least\n                          3 + 5*N .\nNote that for COMPZ = 'I' or 'V', then if N is less than or\nequal to the minimum divide size, usually 25, then LIWORK\nneed only be 1.\n\nIf LIWORK = -1, then a workspace query is assumed; the\nroutine only calculates the optimal sizes of the WORK, RWORK\nand IWORK arrays, returns these values as the first entries\nof the WORK, RWORK and IWORK arrays, and no error message\nrelated to LWORK or LRWORK or LIWORK is issued by XERBLA."), ('INFO', 'INFO is INTEGER\n= 0:  successful exit.\n< 0:  if INFO = -i, the i-th argument had an illegal value.\n> 0:  The algorithm failed to compute an eigenvalue while\n      working on the submatrix lying in rows and columns\n      INFO/(N+1) through mod(INFO,N+1).'))
