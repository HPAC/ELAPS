(('dgesvd', 'DGESVD computes the singular value decomposition (SVD) of a real\nM-by-N matrix A, optionally computing the left and/or right singular\nvectors. The SVD is written\n\n     A = U * SIGMA * transpose(V)\n\nwhere SIGMA is an M-by-N matrix which is zero except for its\nmin(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and\nV is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA\nare the singular values of A; they are real and non-negative, and\nare returned in descending order.  The first min(m,n) columns of\nU and V are the left and right singular vectors of A.\n\nNote that the routine returns V**T, not V.'), ('JOBU', "JOBU is CHARACTER*1\nSpecifies options for computing all or part of the matrix U:\n= 'A':  all M columns of U are returned in array U:\n= 'S':  the first min(m,n) columns of U (the left singular\n        vectors) are returned in the array U;\n= 'O':  the first min(m,n) columns of U (the left singular\n        vectors) are overwritten on the array A;\n= 'N':  no columns of U (no left singular vectors) are\n        computed."), ('JOBVT', "JOBVT is CHARACTER*1\nSpecifies options for computing all or part of the matrix\nV**T:\n= 'A':  all N rows of V**T are returned in the array VT;\n= 'S':  the first min(m,n) rows of V**T (the right singular\n        vectors) are returned in the array VT;\n= 'O':  the first min(m,n) rows of V**T (the right singular\n        vectors) are overwritten on the array A;\n= 'N':  no rows of V**T (no right singular vectors) are\n        computed.\n\nJOBVT and JOBU cannot both be 'O'."), ('M', 'M is INTEGER\nThe number of rows of the input matrix A.  M >= 0.'), ('N', 'N is INTEGER\nThe number of columns of the input matrix A.  N >= 0.'), ('A', "A is DOUBLE PRECISION array, dimension (LDA,N)\nOn entry, the M-by-N matrix A.\nOn exit,\nif JOBU = 'O',  A is overwritten with the first min(m,n)\n                columns of U (the left singular vectors,\n                stored columnwise);\nif JOBVT = 'O', A is overwritten with the first min(m,n)\n                rows of V**T (the right singular vectors,\n                stored rowwise);\nif JOBU .ne. 'O' and JOBVT .ne. 'O', the contents of A\n                are destroyed."), ('LDA', 'LDA is INTEGER\nThe leading dimension of the array A.  LDA >= max(1,M).'), ('S', 'S is DOUBLE PRECISION array, dimension (min(M,N))\nThe singular values of A, sorted so that S(i) >= S(i+1).'), ('U', "U is DOUBLE PRECISION array, dimension (LDU,UCOL)\n(LDU,M) if JOBU = 'A' or (LDU,min(M,N)) if JOBU = 'S'.\nIf JOBU = 'A', U contains the M-by-M orthogonal matrix U;\nif JOBU = 'S', U contains the first min(m,n) columns of U\n(the left singular vectors, stored columnwise);\nif JOBU = 'N' or 'O', U is not referenced."), ('LDU', "LDU is INTEGER\nThe leading dimension of the array U.  LDU >= 1; if\nJOBU = 'S' or 'A', LDU >= M."), ('VT', "VT is DOUBLE PRECISION array, dimension (LDVT,N)\nIf JOBVT = 'A', VT contains the N-by-N orthogonal matrix\nV**T;\nif JOBVT = 'S', VT contains the first min(m,n) rows of\nV**T (the right singular vectors, stored rowwise);\nif JOBVT = 'N' or 'O', VT is not referenced."), ('LDVT', "LDVT is INTEGER\nThe leading dimension of the array VT.  LDVT >= 1; if\nJOBVT = 'A', LDVT >= N; if JOBVT = 'S', LDVT >= min(M,N)."), ('WORK', 'WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))\nOn exit, if INFO = 0, WORK(1) returns the optimal LWORK;\nif INFO > 0, WORK(2:MIN(M,N)) contains the unconverged\nsuperdiagonal elements of an upper bidiagonal matrix B\nwhose diagonal is in S (not necessarily sorted). B\nsatisfies A = U * B * VT, so it has the same singular values\nas A, and singular vectors related by U and VT.'), ('LWORK', "LWORK is INTEGER\nThe dimension of the array WORK.\nLWORK >= MAX(1,5*MIN(M,N)) for the paths (see comments inside code):\n   - PATH 1  (M much larger than N, JOBU='N') \n   - PATH 1t (N much larger than M, JOBVT='N')\nLWORK >= MAX(1,3*MIN(M,N)+MAX(M,N),5*MIN(M,N)) for the other paths\nFor good performance, LWORK should generally be larger.\n\nIf LWORK = -1, then a workspace query is assumed; the routine\nonly calculates the optimal size of the WORK array, returns\nthis value as the first entry of the WORK array, and no error\nmessage related to LWORK is issued by XERBLA."), ('INFO', 'INFO is INTEGER\n= 0:  successful exit.\n< 0:  if INFO = -i, the i-th argument had an illegal value.\n> 0:  if DBDSQR did not converge, INFO specifies how many\n      superdiagonals of an intermediate bidiagonal form B\n      did not converge to zero. See the description of WORK\n      above for details.'))
