(('cggesx', 'CGGESX computes for a pair of N-by-N complex nonsymmetric matrices\n(A,B), the generalized eigenvalues, the complex Schur form (S,T),\nand, optionally, the left and/or right matrices of Schur vectors (VSL\nand VSR).  This gives the generalized Schur factorization\n\n     (A,B) = ( (VSL) S (VSR)**H, (VSL) T (VSR)**H )\n\nwhere (VSR)**H is the conjugate-transpose of VSR.\n\nOptionally, it also orders the eigenvalues so that a selected cluster\nof eigenvalues appears in the leading diagonal blocks of the upper\ntriangular matrix S and the upper triangular matrix T; computes\na reciprocal condition number for the average of the selected\neigenvalues (RCONDE); and computes a reciprocal condition number for\nthe right and left deflating subspaces corresponding to the selected\neigenvalues (RCONDV). The leading columns of VSL and VSR then form\nan orthonormal basis for the corresponding left and right eigenspaces\n(deflating subspaces).\n\nA generalized eigenvalue for a pair of matrices (A,B) is a scalar w\nor a ratio alpha/beta = w, such that  A - w*B is singular.  It is\nusually represented as the pair (alpha,beta), as there is a\nreasonable interpretation for beta=0 or for both being zero.\n\nA pair of matrices (S,T) is in generalized complex Schur form if T is\nupper triangular with non-negative diagonal and S is upper\ntriangular.'), ('JOBVSL', "JOBVSL is CHARACTER*1\n= 'N':  do not compute the left Schur vectors;\n= 'V':  compute the left Schur vectors."), ('JOBVSR', "JOBVSR is CHARACTER*1\n= 'N':  do not compute the right Schur vectors;\n= 'V':  compute the right Schur vectors."), ('SORT', "SORT is CHARACTER*1\nSpecifies whether or not to order the eigenvalues on the\ndiagonal of the generalized Schur form.\n= 'N':  Eigenvalues are not ordered;\n= 'S':  Eigenvalues are ordered (see SELCTG)."), ('SELCTG', "SELCTG is procedure) LOGICAL FUNCTION of two COMPLEX arguments\nSELCTG must be declared EXTERNAL in the calling subroutine.\nIf SORT = 'N', SELCTG is not referenced.\nIf SORT = 'S', SELCTG is used to select eigenvalues to sort\nto the top left of the Schur form.\nNote that a selected complex eigenvalue may no longer satisfy\nSELCTG(ALPHA(j),BETA(j)) = .TRUE. after ordering, since\nordering may change the value of complex eigenvalues\n(especially if the eigenvalue is ill-conditioned), in this\ncase INFO is set to N+3 see INFO below)."), ('SENSE', "SENSE is CHARACTER*1\nDetermines which reciprocal condition numbers are computed.\n= 'N' : None are computed;\n= 'E' : Computed for average of selected eigenvalues only;\n= 'V' : Computed for selected deflating subspaces only;\n= 'B' : Computed for both.\nIf SENSE = 'E', 'V', or 'B', SORT must equal 'S'."), ('N', 'N is INTEGER\nThe order of the matrices A, B, VSL, and VSR.  N >= 0.'), ('A', 'A is COMPLEX array, dimension (LDA, N)\nOn entry, the first of the pair of matrices.\nOn exit, A has been overwritten by its generalized Schur\nform S.'), ('LDA', 'LDA is INTEGER\nThe leading dimension of A.  LDA >= max(1,N).'), ('B', 'B is COMPLEX array, dimension (LDB, N)\nOn entry, the second of the pair of matrices.\nOn exit, B has been overwritten by its generalized Schur\nform T.'), ('LDB', 'LDB is INTEGER\nThe leading dimension of B.  LDB >= max(1,N).'), ('SDIM', "SDIM is INTEGER\nIf SORT = 'N', SDIM = 0.\nIf SORT = 'S', SDIM = number of eigenvalues (after sorting)\nfor which SELCTG is true."), ('ALPHA', 'ALPHA is COMPLEX array, dimension (N)'), ('BETA', 'BETA is COMPLEX array, dimension (N)\nOn exit, ALPHA(j)/BETA(j), j=1,...,N, will be the\ngeneralized eigenvalues.  ALPHA(j) and BETA(j),j=1,...,N  are\nthe diagonals of the complex Schur form (S,T).  BETA(j) will\nbe non-negative real.\n\nNote: the quotients ALPHA(j)/BETA(j) may easily over- or\nunderflow, and BETA(j) may even be zero.  Thus, the user\nshould avoid naively computing the ratio alpha/beta.\nHowever, ALPHA will be always less than and usually\ncomparable with norm(A) in magnitude, and BETA always less\nthan and usually comparable with norm(B).'), ('VSL', "VSL is COMPLEX array, dimension (LDVSL,N)\nIf JOBVSL = 'V', VSL will contain the left Schur vectors.\nNot referenced if JOBVSL = 'N'."), ('LDVSL', "LDVSL is INTEGER\nThe leading dimension of the matrix VSL. LDVSL >=1, and\nif JOBVSL = 'V', LDVSL >= N."), ('VSR', "VSR is COMPLEX array, dimension (LDVSR,N)\nIf JOBVSR = 'V', VSR will contain the right Schur vectors.\nNot referenced if JOBVSR = 'N'."), ('LDVSR', "LDVSR is INTEGER\nThe leading dimension of the matrix VSR. LDVSR >= 1, and\nif JOBVSR = 'V', LDVSR >= N."), ('RCONDE', "RCONDE is REAL array, dimension ( 2 )\nIf SENSE = 'E' or 'B', RCONDE(1) and RCONDE(2) contain the\nreciprocal condition numbers for the average of the selected\neigenvalues.\nNot referenced if SENSE = 'N' or 'V'."), ('RCONDV', "RCONDV is REAL array, dimension ( 2 )\nIf SENSE = 'V' or 'B', RCONDV(1) and RCONDV(2) contain the\nreciprocal condition number for the selected deflating\nsubspaces.\nNot referenced if SENSE = 'N' or 'E'."), ('WORK', 'WORK is COMPLEX array, dimension (MAX(1,LWORK))\nOn exit, if INFO = 0, WORK(1) returns the optimal LWORK.'), ('LWORK', "LWORK is INTEGER\nThe dimension of the array WORK.\nIf N = 0, LWORK >= 1, else if SENSE = 'E', 'V', or 'B',\nLWORK >= MAX(1,2*N,2*SDIM*(N-SDIM)), else\nLWORK >= MAX(1,2*N).  Note that 2*SDIM*(N-SDIM) <= N*N/2.\nNote also that an error is only returned if\nLWORK < MAX(1,2*N), but if SENSE = 'E' or 'V' or 'B' this may\nnot be large enough.\n\nIf LWORK = -1, then a workspace query is assumed; the routine\nonly calculates the bound on the optimal size of the WORK\narray and the minimum size of the IWORK array, returns these\nvalues as the first entries of the WORK and IWORK arrays, and\nno error message related to LWORK or LIWORK is issued by\nXERBLA."), ('RWORK', 'RWORK is REAL array, dimension ( 8*N )\nReal workspace.'), ('IWORK', 'IWORK is INTEGER array, dimension (MAX(1,LIWORK))\nOn exit, if INFO = 0, IWORK(1) returns the minimum LIWORK.'), ('LIWORK', "LIWORK is INTEGER\nThe dimension of the array WORK.\nIf SENSE = 'N' or N = 0, LIWORK >= 1, otherwise\nLIWORK >= N+2.\n\nIf LIWORK = -1, then a workspace query is assumed; the\nroutine only calculates the bound on the optimal size of the\nWORK array and the minimum size of the IWORK array, returns\nthese values as the first entries of the WORK and IWORK\narrays, and no error message related to LWORK or LIWORK is\nissued by XERBLA."), ('BWORK', "BWORK is LOGICAL array, dimension (N)\nNot referenced if SORT = 'N'."), ('INFO', 'INFO is INTEGER\n= 0:  successful exit\n< 0:  if INFO = -i, the i-th argument had an illegal value.\n= 1,...,N:\n      The QZ iteration failed.  (A,B) are not in Schur\n      form, but ALPHA(j) and BETA(j) should be correct for\n      j=INFO+1,...,N.\n> N:  =N+1: other than QZ iteration failed in CHGEQZ\n      =N+2: after reordering, roundoff changed values of\n            some complex eigenvalues so that leading\n            eigenvalues in the Generalized Schur form no\n            longer satisfy SELCTG=.TRUE.  This could also\n            be caused due to scaling.\n      =N+3: reordering failed in CTGSEN.'))
