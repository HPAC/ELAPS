(('dlasda', 'Using a divide and conquer approach, DLASDA computes the singular\nvalue decomposition (SVD) of a real upper bidiagonal N-by-M matrix\nB with diagonal D and offdiagonal E, where M = N + SQRE. The\nalgorithm computes the singular values in the SVD B = U * S * VT.\nThe orthogonal matrices U and VT are optionally computed in\ncompact form.\n\nA related subroutine, DLASD0, computes the singular values and\nthe singular vectors in explicit form.'), ('ICOMPQ', 'ICOMPQ is INTEGER\npecifies whether singular vectors are to be computed\nn compact form, as follows\n 0: Compute singular values only.\n 1: Compute singular vectors of upper bidiagonal\n    matrix in compact form.'), ('SMLSIZ', 'SMLSIZ is INTEGER\nhe maximum size of the subproblems at the bottom of the\nomputation tree.'), ('N', 'N is INTEGER\nhe row dimension of the upper bidiagonal matrix. This is\nlso the dimension of the main diagonal array D.'), ('SQRE', 'SQRE is INTEGER\npecifies the column dimension of the bidiagonal matrix.\n 0: The bidiagonal matrix has column dimension M = N;\n 1: The bidiagonal matrix has column dimension M = N + 1.'), ('D', 'D is DOUBLE PRECISION array, dimension ( N )\nn entry D contains the main diagonal of the bidiagonal\natrix. On exit D, if INFO = 0, contains its singular values.'), ('E', 'E is DOUBLE PRECISION array, dimension ( M-1 )\nontains the subdiagonal entries of the bidiagonal matrix.\nn exit, E has been destroyed.'), ('U', 'U is DOUBLE PRECISION array,\nimension ( LDU, SMLSIZ ) if ICOMPQ = 1, and not referenced\nf ICOMPQ = 0. If ICOMPQ = 1, on exit, U contains the left\ningular vector matrices of all subproblems at the bottom\nevel.'), ('LDU', 'LDU is INTEGER, LDU = > N.\nhe leading dimension of arrays U, VT, DIFL, DIFR, POLES,\nIVNUM, and Z.'), ('VT', 'VT is DOUBLE PRECISION array,\nimension ( LDU, SMLSIZ+1 ) if ICOMPQ = 1, and not referenced\nf ICOMPQ = 0. If ICOMPQ = 1, on exit, VT**T contains the right\ningular vector matrices of all subproblems at the bottom\nevel.'), ('K', 'K is INTEGER array,\nimension ( N ) if ICOMPQ = 1 and dimension 1 if ICOMPQ = 0.\nf ICOMPQ = 1, on exit, K(I) is the dimension of the I-th\necular equation on the computation tree.'), ('DIFL', 'DIFL is DOUBLE PRECISION array, dimension ( LDU, NLVL ),\nhere NLVL = floor(log_2 (N/SMLSIZ))).'), ('DIFR', 'DIFR is DOUBLE PRECISION array,\n        dimension ( LDU, 2 * NLVL ) if ICOMPQ = 1 and\n        dimension ( N ) if ICOMPQ = 0.\nf ICOMPQ = 1, on exit, DIFL(1:N, I) and DIFR(1:N, 2 * I - 1)\necord distances between singular values on the I-th\nevel and singular values on the (I -1)-th level, and\nIFR(1:N, 2 * I ) contains the normalizing factors for\nhe right singular vector matrix. See DLASD8 for details.'), ('Z', 'Z is DOUBLE PRECISION array,\n        dimension ( LDU, NLVL ) if ICOMPQ = 1 and\n        dimension ( N ) if ICOMPQ = 0.\nhe first K elements of Z(1, I) contain the components of\nhe deflation-adjusted updating row vector for subproblems\nn the I-th level.'), ('POLES', 'POLES is DOUBLE PRECISION array,\nimension ( LDU, 2 * NLVL ) if ICOMPQ = 1, and not referenced\nf ICOMPQ = 0. If ICOMPQ = 1, on exit, POLES(1, 2*I - 1) and\nOLES(1, 2*I) contain  the new and old singular values\nnvolved in the secular equations on the I-th level.'), ('GIVPTR', 'GIVPTR is INTEGER array,\nimension ( N ) if ICOMPQ = 1, and not referenced if\nCOMPQ = 0. If ICOMPQ = 1, on exit, GIVPTR( I ) records\nhe number of Givens rotations performed on the I-th\nroblem on the computation tree.'), ('GIVCOL', 'GIVCOL is INTEGER array,\nimension ( LDGCOL, 2 * NLVL ) if ICOMPQ = 1, and not\neferenced if ICOMPQ = 0. If ICOMPQ = 1, on exit, for each I,\nIVCOL(1, 2 *I - 1) and GIVCOL(1, 2 *I) record the locations\nf Givens rotations performed on the I-th level on the\nomputation tree.'), ('LDGCOL', 'LDGCOL is INTEGER, LDGCOL = > N.\nhe leading dimension of arrays GIVCOL and PERM.'), ('PERM', 'PERM is INTEGER array,\nimension ( LDGCOL, NLVL ) if ICOMPQ = 1, and not referenced\nf ICOMPQ = 0. If ICOMPQ = 1, on exit, PERM(1, I) records\nermutations done on the I-th level of the computation tree.'), ('GIVNUM', 'GIVNUM is DOUBLE PRECISION array,\nimension ( LDU,  2 * NLVL ) if ICOMPQ = 1, and not\neferenced if ICOMPQ = 0. If ICOMPQ = 1, on exit, for each I,\nIVNUM(1, 2 *I - 1) and GIVNUM(1, 2 *I) record the C- and S-\nalues of Givens rotations performed on the I-th level on\nhe computation tree.'), ('C', 'C is DOUBLE PRECISION array,\nimension ( N ) if ICOMPQ = 1, and dimension 1 if ICOMPQ = 0.\nf ICOMPQ = 1 and the I-th subproblem is not square, on exit,\n( I ) contains the C-value of a Givens rotation related to\nhe right null space of the I-th subproblem.'), ('S', 'S is DOUBLE PRECISION array, dimension ( N ) if\nCOMPQ = 1, and dimension 1 if ICOMPQ = 0. If ICOMPQ = 1\nnd the I-th subproblem is not square, on exit, S( I )\nontains the S-value of a Givens rotation related to\nhe right null space of the I-th subproblem.'), ('WORK', 'WORK is DOUBLE PRECISION array, dimension\n6 * N + (SMLSIZ + 1)*(SMLSIZ + 1)).'), ('IWORK', 'IWORK is INTEGER array.\nimension must be at least (7 * N).'), ('INFO', 'INFO is INTEGER\n= 0:  successful exit.\n< 0:  if INFO = -i, the i-th argument had an illegal value.\n> 0:  if INFO = 1, a singular value did not converge'))
