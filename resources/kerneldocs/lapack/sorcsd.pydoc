(('sorcsd', 'SORCSD computes the CS decomposition of an M-by-M partitioned\northogonal matrix X:\n\n                                [  I  0  0 |  0  0  0 ]\n                                [  0  C  0 |  0 -S  0 ]\n    [ X11 | X12 ]   [ U1 |    ] [  0  0  0 |  0  0 -I ] [ V1 |    ]**T\nX = [-----------] = [---------] [---------------------] [---------]   .\n    [ X21 | X22 ]   [    | U2 ] [  0  0  0 |  I  0  0 ] [    | V2 ]\n                                [  0  S  0 |  0  C  0 ]\n                                [  0  0  I |  0  0  0 ]\n\nX11 is P-by-Q. The orthogonal matrices U1, U2, V1, and V2 are P-by-P,\n(M-P)-by-(M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. C and S are\nR-by-R nonnegative diagonal matrices satisfying C^2 + S^2 = I, in\nwhich R = MIN(P,M-P,Q,M-Q).'), ('JOBU1', "JOBU1 is CHARACTER\n= 'Y':      U1 is computed;\notherwise:  U1 is not computed."), ('JOBU2', "JOBU2 is CHARACTER\n= 'Y':      U2 is computed;\notherwise:  U2 is not computed."), ('JOBV1T', "JOBV1T is CHARACTER\n= 'Y':      V1T is computed;\notherwise:  V1T is not computed."), ('JOBV2T', "JOBV2T is CHARACTER\n= 'Y':      V2T is computed;\notherwise:  V2T is not computed."), ('TRANS', "TRANS is CHARACTER\n= 'T':      X, U1, U2, V1T, and V2T are stored in row-major\n            order;\notherwise:  X, U1, U2, V1T, and V2T are stored in column-\n            major order."), ('SIGNS', 'SIGNS is CHARACTER\n= \'O\':      The lower-left block is made nonpositive (the\n            "other" convention);\notherwise:  The upper-right block is made nonpositive (the\n            "default" convention).'), ('M', 'M is INTEGER\nThe number of rows and columns in X.'), ('P', 'P is INTEGER\nThe number of rows in X11 and X12. 0 <= P <= M.'), ('Q', 'Q is INTEGER\nThe number of columns in X11 and X21. 0 <= Q <= M.'), ('X11', 'X11 is REAL array, dimension (LDX11,Q)\nOn entry, part of the orthogonal matrix whose CSD is desired.'), ('LDX11', 'LDX11 is INTEGER\nThe leading dimension of X11. LDX11 >= MAX(1,P).'), ('X12', 'X12 is REAL array, dimension (LDX12,M-Q)\nOn entry, part of the orthogonal matrix whose CSD is desired.'), ('LDX12', 'LDX12 is INTEGER\nThe leading dimension of X12. LDX12 >= MAX(1,P).'), ('X21', 'X21 is REAL array, dimension (LDX21,Q)\nOn entry, part of the orthogonal matrix whose CSD is desired.'), ('LDX21', 'LDX21 is INTEGER\nThe leading dimension of X11. LDX21 >= MAX(1,M-P).'), ('X22', 'X22 is REAL array, dimension (LDX22,M-Q)\nOn entry, part of the orthogonal matrix whose CSD is desired.'), ('LDX22', 'LDX22 is INTEGER\nThe leading dimension of X11. LDX22 >= MAX(1,M-P).'), ('THETA', 'THETA is REAL array, dimension (R), in which R =\nMIN(P,M-P,Q,M-Q).\nC = DIAG( COS(THETA(1)), ... , COS(THETA(R)) ) and\nS = DIAG( SIN(THETA(1)), ... , SIN(THETA(R)) ).'), ('U1', "U1 is REAL array, dimension (P)\nIf JOBU1 = 'Y', U1 contains the P-by-P orthogonal matrix U1."), ('LDU1', "LDU1 is INTEGER\nThe leading dimension of U1. If JOBU1 = 'Y', LDU1 >=\nMAX(1,P)."), ('U2', "U2 is REAL array, dimension (M-P)\nIf JOBU2 = 'Y', U2 contains the (M-P)-by-(M-P) orthogonal\nmatrix U2."), ('LDU2', "LDU2 is INTEGER\nThe leading dimension of U2. If JOBU2 = 'Y', LDU2 >=\nMAX(1,M-P)."), ('V1T', "V1T is REAL array, dimension (Q)\nIf JOBV1T = 'Y', V1T contains the Q-by-Q matrix orthogonal\nmatrix V1**T."), ('LDV1T', "LDV1T is INTEGER\nThe leading dimension of V1T. If JOBV1T = 'Y', LDV1T >=\nMAX(1,Q)."), ('V2T', "V2T is REAL array, dimension (M-Q)\nIf JOBV2T = 'Y', V2T contains the (M-Q)-by-(M-Q) orthogonal\nmatrix V2**T."), ('LDV2T', "LDV2T is INTEGER\nThe leading dimension of V2T. If JOBV2T = 'Y', LDV2T >=\nMAX(1,M-Q)."), ('WORK', "WORK is REAL array, dimension (MAX(1,LWORK))\nOn exit, if INFO = 0, WORK(1) returns the optimal LWORK.\nIf INFO > 0 on exit, WORK(2:R) contains the values PHI(1),\n..., PHI(R-1) that, together with THETA(1), ..., THETA(R),\ndefine the matrix in intermediate bidiagonal-block form\nremaining after nonconvergence. INFO specifies the number\nof nonzero PHI's."), ('LWORK', 'LWORK is INTEGER\nThe dimension of the array WORK.\n\nIf LWORK = -1, then a workspace query is assumed; the routine\nonly calculates the optimal size of the WORK array, returns\nthis value as the first entry of the work array, and no error\nmessage related to LWORK is issued by XERBLA.'), ('IWORK', 'IWORK is INTEGER array, dimension (M-MIN(P, M-P, Q, M-Q))'), ('INFO', 'INFO is INTEGER\n= 0:  successful exit.\n< 0:  if INFO = -i, the i-th argument had an illegal value.\n> 0:  SBBCSD did not converge. See the description of WORK\n      above for details.'))
