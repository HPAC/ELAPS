(('dlalsd', 'DLALSD uses the singular value decomposition of A to solve the least\nsquares problem of finding X to minimize the Euclidean norm of each\ncolumn of A*X-B, where A is N-by-N upper bidiagonal, and X and B\nare N-by-NRHS. The solution X overwrites B.\n\nThe singular values of A smaller than RCOND times the largest\nsingular value are treated as zero in solving the least squares\nproblem; in this case a minimum norm solution is returned.\nThe actual singular values are returned in D in ascending order.\n\nThis code makes very mild assumptions about floating point\narithmetic. It will work on machines with a guard digit in\nadd/subtract, or on those binary machines without guard digits\nwhich subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.\nIt could conceivably fail on hexadecimal or decimal machines\nwithout guard digits, but we know of none.'), ('UPLO', "UPLO is CHARACTER*1\n 'U': D and E define an upper bidiagonal matrix.\n 'L': D and E define a  lower bidiagonal matrix."), ('SMLSIZ', 'SMLSIZ is INTEGER\nhe maximum size of the subproblems at the bottom of the\nomputation tree.'), ('N', 'N is INTEGER\nhe dimension of the  bidiagonal matrix.  N >= 0.'), ('NRHS', 'NRHS is INTEGER\nhe number of columns of B. NRHS must be at least 1.'), ('D', 'D is DOUBLE PRECISION array, dimension (N)\nn entry D contains the main diagonal of the bidiagonal\natrix. On exit, if INFO = 0, D contains its singular values.'), ('E', 'E is DOUBLE PRECISION array, dimension (N-1)\nontains the super-diagonal entries of the bidiagonal matrix.\nn exit, E has been destroyed.'), ('B', 'B is DOUBLE PRECISION array, dimension (LDB,NRHS)\nn input, B contains the right hand sides of the least\nquares problem. On output, B contains the solution X.'), ('LDB', 'LDB is INTEGER\nhe leading dimension of B in the calling subprogram.\nDB must be at least max(1,N).'), ('RCOND', 'RCOND is DOUBLE PRECISION\nhe singular values of A less than or equal to RCOND times\nhe largest singular value are treated as zero in solving\nhe least squares problem. If RCOND is negative,\nachine precision is used instead.\nor example, if diag(S)*X=B were the least squares problem,\nhere diag(S) is a diagonal matrix of singular values, the\nolution would be X(i) = B(i) / S(i) if S(i) is greater than\nCOND*max(S), and X(i) = 0 if S(i) is less than or equal to\nCOND*max(S).'), ('RANK', 'RANK is INTEGER\nhe number of singular values of A greater than RCOND times\nhe largest singular value.'), ('WORK', 'WORK is DOUBLE PRECISION array, dimension at least\n9*N + 2*N*SMLSIZ + 8*N*NLVL + N*NRHS + (SMLSIZ+1)**2),\nhere NLVL = max(0, INT(log_2 (N/(SMLSIZ+1))) + 1).'), ('IWORK', 'IWORK is INTEGER array, dimension at least\n3*N*NLVL + 11*N)'), ('INFO', 'INFO is INTEGER\n 0:  successful exit.\n 0:  if INFO = -i, the i-th argument had an illegal value.\n 0:  The algorithm failed to compute a singular value while\n     working on the submatrix lying in rows and columns\n     INFO/(N+1) through MOD(INFO,N+1).'))
