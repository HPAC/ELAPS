(('cgeevx', "CGEEVX computes for an N-by-N complex nonsymmetric matrix A, the\neigenvalues and, optionally, the left and/or right eigenvectors.\n\nOptionally also, it computes a balancing transformation to improve\nthe conditioning of the eigenvalues and eigenvectors (ILO, IHI,\nSCALE, and ABNRM), reciprocal condition numbers for the eigenvalues\n(RCONDE), and reciprocal condition numbers for the right\neigenvectors (RCONDV).\n\nThe right eigenvector v(j) of A satisfies\n                 A * v(j) = lambda(j) * v(j)\nwhere lambda(j) is its eigenvalue.\nThe left eigenvector u(j) of A satisfies\n              u(j)**H * A = lambda(j) * u(j)**H\nwhere u(j)**H denotes the conjugate transpose of u(j).\n\nThe computed eigenvectors are normalized to have Euclidean norm\nequal to 1 and largest component real.\n\nBalancing a matrix means permuting the rows and columns to make it\nmore nearly upper triangular, and applying a diagonal similarity\ntransformation D * A * D**(-1), where D is a diagonal matrix, to\nmake its rows and columns closer in norm and the condition numbers\nof its eigenvalues and eigenvectors smaller.  The computed\nreciprocal condition numbers correspond to the balanced matrix.\nPermuting rows and columns will not change the condition numbers\n(in exact arithmetic) but diagonal scaling will.  For further\nexplanation of balancing, see section 4.10.2 of the LAPACK\nUsers' Guide."), ('BALANC', "BALANC is CHARACTER*1\nIndicates how the input matrix should be diagonally scaled\nand/or permuted to improve the conditioning of its\neigenvalues.\n= 'N': Do not diagonally scale or permute;\n= 'P': Perform permutations to make the matrix more nearly\n       upper triangular. Do not diagonally scale;\n= 'S': Diagonally scale the matrix, ie. replace A by\n       D*A*D**(-1), where D is a diagonal matrix chosen\n       to make the rows and columns of A more equal in\n       norm. Do not permute;\n= 'B': Both diagonally scale and permute A.\n\nComputed reciprocal condition numbers will be for the matrix\nafter balancing and/or permuting. Permuting does not change\ncondition numbers (in exact arithmetic), but balancing does."), ('JOBVL', "JOBVL is CHARACTER*1\n= 'N': left eigenvectors of A are not computed;\n= 'V': left eigenvectors of A are computed.\nIf SENSE = 'E' or 'B', JOBVL must = 'V'."), ('JOBVR', "JOBVR is CHARACTER*1\n= 'N': right eigenvectors of A are not computed;\n= 'V': right eigenvectors of A are computed.\nIf SENSE = 'E' or 'B', JOBVR must = 'V'."), ('SENSE', "SENSE is CHARACTER*1\nDetermines which reciprocal condition numbers are computed.\n= 'N': None are computed;\n= 'E': Computed for eigenvalues only;\n= 'V': Computed for right eigenvectors only;\n= 'B': Computed for eigenvalues and right eigenvectors.\n\nIf SENSE = 'E' or 'B', both left and right eigenvectors\nmust also be computed (JOBVL = 'V' and JOBVR = 'V')."), ('N', 'N is INTEGER\nThe order of the matrix A. N >= 0.'), ('A', "A is COMPLEX array, dimension (LDA,N)\nOn entry, the N-by-N matrix A.\nOn exit, A has been overwritten.  If JOBVL = 'V' or\nJOBVR = 'V', A contains the Schur form of the balanced \nversion of the matrix A."), ('LDA', 'LDA is INTEGER\nThe leading dimension of the array A.  LDA >= max(1,N).'), ('W', 'W is COMPLEX array, dimension (N)\nW contains the computed eigenvalues.'), ('VL', "VL is COMPLEX array, dimension (LDVL,N)\nIf JOBVL = 'V', the left eigenvectors u(j) are stored one\nafter another in the columns of VL, in the same order\nas their eigenvalues.\nIf JOBVL = 'N', VL is not referenced.\nu(j) = VL(:,j), the j-th column of VL."), ('LDVL', "LDVL is INTEGER\nThe leading dimension of the array VL.  LDVL >= 1; if\nJOBVL = 'V', LDVL >= N."), ('VR', "VR is COMPLEX array, dimension (LDVR,N)\nIf JOBVR = 'V', the right eigenvectors v(j) are stored one\nafter another in the columns of VR, in the same order\nas their eigenvalues.\nIf JOBVR = 'N', VR is not referenced.\nv(j) = VR(:,j), the j-th column of VR."), ('LDVR', "LDVR is INTEGER\nThe leading dimension of the array VR.  LDVR >= 1; if\nJOBVR = 'V', LDVR >= N."), ('ILO', 'ILO is INTEGER'), ('IHI', 'IHI is INTEGER\nILO and IHI are integer values determined when A was\nbalanced.  The balanced A(i,j) = 0 if I > J and\nJ = 1,...,ILO-1 or I = IHI+1,...,N.'), ('SCALE', 'SCALE is REAL array, dimension (N)\nDetails of the permutations and scaling factors applied\nwhen balancing A.  If P(j) is the index of the row and column\ninterchanged with row and column j, and D(j) is the scaling\nfactor applied to row and column j, then\nSCALE(J) = P(J),    for J = 1,...,ILO-1\n         = D(J),    for J = ILO,...,IHI\n         = P(J)     for J = IHI+1,...,N.\nThe order in which the interchanges are made is N to IHI+1,\nthen 1 to ILO-1.'), ('ABNRM', 'ABNRM is REAL\nThe one-norm of the balanced matrix (the maximum\nof the sum of absolute values of elements of any column).'), ('RCONDE', 'RCONDE is REAL array, dimension (N)\nRCONDE(j) is the reciprocal condition number of the j-th\neigenvalue.'), ('RCONDV', 'RCONDV is REAL array, dimension (N)\nRCONDV(j) is the reciprocal condition number of the j-th\nright eigenvector.'), ('WORK', 'WORK is COMPLEX array, dimension (MAX(1,LWORK))\nOn exit, if INFO = 0, WORK(1) returns the optimal LWORK.'), ('LWORK', "LWORK is INTEGER\nThe dimension of the array WORK.  If SENSE = 'N' or 'E',\nLWORK >= max(1,2*N), and if SENSE = 'V' or 'B',\nLWORK >= N*N+2*N.\nFor good performance, LWORK must generally be larger.\n\nIf LWORK = -1, then a workspace query is assumed; the routine\nonly calculates the optimal size of the WORK array, returns\nthis value as the first entry of the WORK array, and no error\nmessage related to LWORK is issued by XERBLA."), ('RWORK', 'RWORK is REAL array, dimension (2*N)'), ('INFO', 'INFO is INTEGER\n= 0:  successful exit\n< 0:  if INFO = -i, the i-th argument had an illegal value.\n> 0:  if INFO = i, the QR algorithm failed to compute all the\n      eigenvalues, and no eigenvectors or condition numbers\n      have been computed; elements 1:ILO-1 and i+1:N of W\n      contain eigenvalues which have converged.'))
