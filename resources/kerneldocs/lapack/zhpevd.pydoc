(('zhpevd', 'ZHPEVD computes all the eigenvalues and, optionally, eigenvectors of\na complex Hermitian matrix A in packed storage.  If eigenvectors are\ndesired, it uses a divide and conquer algorithm.\n\nThe divide and conquer algorithm makes very mild assumptions about\nfloating point arithmetic. It will work on machines with a guard\ndigit in add/subtract, or on those binary machines without guard\ndigits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or\nCray-2. It could conceivably fail on hexadecimal or decimal machines\nwithout guard digits, but we know of none.'), ('JOBZ', "JOBZ is CHARACTER*1\n= 'N':  Compute eigenvalues only;\n= 'V':  Compute eigenvalues and eigenvectors."), ('UPLO', "UPLO is CHARACTER*1\n= 'U':  Upper triangle of A is stored;\n= 'L':  Lower triangle of A is stored."), ('N', 'N is INTEGER\nThe order of the matrix A.  N >= 0.'), ('AP', "AP is COMPLEX*16 array, dimension (N*(N+1)/2)\nOn entry, the upper or lower triangle of the Hermitian matrix\nA, packed columnwise in a linear array.  The j-th column of A\nis stored in the array AP as follows:\nif UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\nif UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.\n\nOn exit, AP is overwritten by values generated during the\nreduction to tridiagonal form.  If UPLO = 'U', the diagonal\nand first superdiagonal of the tridiagonal matrix T overwrite\nthe corresponding elements of A, and if UPLO = 'L', the\ndiagonal and first subdiagonal of T overwrite the\ncorresponding elements of A."), ('W', 'W is DOUBLE PRECISION array, dimension (N)\nIf INFO = 0, the eigenvalues in ascending order.'), ('Z', "Z is COMPLEX*16 array, dimension (LDZ, N)\nIf JOBZ = 'V', then if INFO = 0, Z contains the orthonormal\neigenvectors of the matrix A, with the i-th column of Z\nholding the eigenvector associated with W(i).\nIf JOBZ = 'N', then Z is not referenced."), ('LDZ', "LDZ is INTEGER\nThe leading dimension of the array Z.  LDZ >= 1, and if\nJOBZ = 'V', LDZ >= max(1,N)."), ('WORK', 'WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))\nOn exit, if INFO = 0, WORK(1) returns the required LWORK.'), ('LWORK', "LWORK is INTEGER\nThe dimension of array WORK.\nIf N <= 1,               LWORK must be at least 1.\nIf JOBZ = 'N' and N > 1, LWORK must be at least N.\nIf JOBZ = 'V' and N > 1, LWORK must be at least 2*N.\n\nIf LWORK = -1, then a workspace query is assumed; the routine\nonly calculates the required sizes of the WORK, RWORK and\nIWORK arrays, returns these values as the first entries of\nthe WORK, RWORK and IWORK arrays, and no error message\nrelated to LWORK or LRWORK or LIWORK is issued by XERBLA."), ('RWORK', 'RWORK is DOUBLE PRECISION array,\n                               dimension (LRWORK)\nOn exit, if INFO = 0, RWORK(1) returns the required LRWORK.'), ('LRWORK', "LRWORK is INTEGER\nThe dimension of array RWORK.\nIf N <= 1,               LRWORK must be at least 1.\nIf JOBZ = 'N' and N > 1, LRWORK must be at least N.\nIf JOBZ = 'V' and N > 1, LRWORK must be at least\n          1 + 5*N + 2*N**2.\n\nIf LRWORK = -1, then a workspace query is assumed; the\nroutine only calculates the required sizes of the WORK, RWORK\nand IWORK arrays, returns these values as the first entries\nof the WORK, RWORK and IWORK arrays, and no error message\nrelated to LWORK or LRWORK or LIWORK is issued by XERBLA."), ('IWORK', 'IWORK is INTEGER array, dimension (MAX(1,LIWORK))\nOn exit, if INFO = 0, IWORK(1) returns the required LIWORK.'), ('LIWORK', "LIWORK is INTEGER\nThe dimension of array IWORK.\nIf JOBZ  = 'N' or N <= 1, LIWORK must be at least 1.\nIf JOBZ  = 'V' and N > 1, LIWORK must be at least 3 + 5*N.\n\nIf LIWORK = -1, then a workspace query is assumed; the\nroutine only calculates the required sizes of the WORK, RWORK\nand IWORK arrays, returns these values as the first entries\nof the WORK, RWORK and IWORK arrays, and no error message\nrelated to LWORK or LRWORK or LIWORK is issued by XERBLA."), ('INFO', 'INFO is INTEGER\n= 0:  successful exit\n< 0:  if INFO = -i, the i-th argument had an illegal value.\n> 0:  if INFO = i, the algorithm failed to converge; i\n      off-diagonal elements of an intermediate tridiagonal\n      form did not converge to zero.'))
