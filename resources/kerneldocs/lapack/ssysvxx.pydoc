(('ssysvxx', 'SSYSVXX uses the diagonal pivoting factorization to compute the\nsolution to a real system of linear equations A * X = B, where A\nis an N-by-N symmetric matrix and X and B are N-by-NRHS matrices.\n\nIf requested, both normwise and maximum componentwise error bounds\nare returned. SSYSVXX will return a solution with a tiny\nguaranteed error (O(eps) where eps is the working machine\nprecision) unless the matrix is very ill-conditioned, in which\ncase a warning is returned. Relevant condition numbers also are\ncalculated and returned.\n\nSSYSVXX accepts user-provided factorizations and equilibration\nfactors; see the definitions of the FACT and EQUED options.\nSolving with refinement and using a factorization from a previous\nSSYSVXX call will also produce a solution with either O(eps)\nerrors or warnings, but we cannot make that claim for general\nuser-provided factorizations and equilibration factors if they\ndiffer from what SSYSVXX would itself produce.'), ('FACT', "FACT is CHARACTER*1\nfies whether or not the factored form of the matrix A is\nied on entry, and if not, whether the matrix A should be\nibrated before it is factored.\nF':  On entry, AF and IPIV contain the factored form of A.\n     If EQUED is not 'N', the matrix A has been\n     equilibrated with scaling factors given by S.\n     A, AF, and IPIV are not modified.\nN':  The matrix A will be copied to AF and factored.\nE':  The matrix A will be equilibrated if necessary, then\n     copied to AF and factored."), ('UPLO', "UPLO is CHARACTER*1\nU':  Upper triangle of A is stored;\nL':  Lower triangle of A is stored."), ('N', 'N is INTEGER\number of linear equations, i.e., the order of the\nx A.  N >= 0.'), ('NRHS', 'NRHS is INTEGER\number of right hand sides, i.e., the number of columns\ne matrices B and X.  NRHS >= 0.'), ('A', "A is REAL array, dimension (LDA,N)\nymmetric matrix A.  If UPLO = 'U', the leading N-by-N\n triangular part of A contains the upper triangular\nof the matrix A, and the strictly lower triangular\nof A is not referenced.  If UPLO = 'L', the leading\nN lower triangular part of A contains the lower\ngular part of the matrix A, and the strictly upper\ngular part of A is not referenced.\n\nit, if FACT = 'E' and EQUED = 'Y', A is overwritten by\nS)*A*diag(S)."), ('LDA', 'LDA is INTEGER\neading dimension of the array A.  LDA >= max(1,N).'), ('AF', "AF is REAL array, dimension (LDAF,N)\nCT = 'F', then AF is an input argument and on entry\nins the block diagonal matrix D and the multipliers\nto obtain the factor U or L from the factorization A =\n**T or A = L*D*L**T as computed by SSYTRF.\n\nCT = 'N', then AF is an output argument and on exit\nns the block diagonal matrix D and the multipliers\nto obtain the factor U or L from the factorization A =\n**T or A = L*D*L**T."), ('LDAF', 'LDAF is INTEGER\neading dimension of the array AF.  LDAF >= max(1,N).'), ('IPIV', "IPIV is INTEGER array, dimension (N)\nCT = 'F', then IPIV is an input argument and on entry\nins details of the interchanges and the block\nture of D, as determined by SSYTRF.  If IPIV(k) > 0,\nrows and columns k and IPIV(k) were interchanged and\n) is a 1-by-1 diagonal block.  If UPLO = 'U' and\nk) = IPIV(k-1) < 0, then rows and columns k-1 and\n(k) were interchanged and D(k-1:k,k-1:k) is a 2-by-2\nnal block.  If UPLO = 'L' and IPIV(k) = IPIV(k+1) < 0,\nrows and columns k+1 and -IPIV(k) were interchanged\n(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n\nCT = 'N', then IPIV is an output argument and on exit\nins details of the interchanges and the block\nture of D, as determined by SSYTRF."), ('EQUED', "EQUED is CHARACTER*1\nfies the form of equilibration that was done.\nN':  No equilibration (always true if FACT = 'N').\nY':  Both row and column equilibration, i.e., A has been\n     replaced by diag(S) * A * diag(S).\n is an input argument if FACT = 'F'; otherwise, it is an\nt argument."), ('S', "S is REAL array, dimension (N)\ncale factors for A.  If EQUED = 'Y', A is multiplied on\neft and right by diag(S).  S is an input argument if FACT =\notherwise, S is an output argument.  If FACT = 'F' and EQUED\n, each element of S must be positive.  If S is output, each\nnt of S is a power of the radix. If S is input, each element\nshould be a power of the radix to ensure a reliable solution\nrror estimates. Scaling by powers of the radix does not cause\ning errors unless the result underflows or overflows.\ning errors during scaling lead to refining with a matrix that\nt equivalent to the input matrix, producing error estimates\nmay not be reliable."), ('B', "B is REAL array, dimension (LDB,NRHS)\ntry, the N-by-NRHS right hand side matrix B.\nit,\nUED = 'N', B is not modified;\nUED = 'Y', B is overwritten by diag(S)*B;"), ('LDB', 'LDB is INTEGER\neading dimension of the array B.  LDB >= max(1,N).'), ('X', "X is REAL array, dimension (LDX,NRHS)\nFO = 0, the N-by-NRHS solution matrix X to the original\nm of equations.  Note that A and B are modified on exit if\n .ne. 'N', and the solution to the equilibrated system is\niag(S))*X."), ('LDX', 'LDX is INTEGER\neading dimension of the array X.  LDX >= max(1,N).'), ('RCOND', 'RCOND is REAL\nrocal scaled condition number.  This is an estimate of the\nrocal Skeel condition number of the matrix A after\nibration (if done).  If this is less than the machine\nsion (in particular, if it is zero), the matrix is singular\nrking precision.  Note that the error may still be small even\nis number is very small and the matrix appears ill-\ntioned.'), ('RPVGRW', 'RPVGRW is REAL\nrocal pivot growth.  On exit, this contains the reciprocal\n growth factor norm(A)/norm(U). The "max absolute element"\nis used.  If this is much less than 1, then the stability of\nU factorization of the (equilibrated) matrix A could be poor.\nalso means that the solution X, estimated condition numbers,\nrror bounds could be unreliable. If factorization fails with\nO<=N, then this contains the reciprocal pivot growth factor\nhe leading INFO columns of A.'), ('BERR', 'BERR is REAL array, dimension (NRHS)\nnentwise relative backward error.  This is the\nnentwise relative backward error of each solution vector X(j)\n, the smallest relative change in any element of A or B that\n X(j) an exact solution).'), ('N_ERR_BNDS', 'N_ERR_BNDS is INTEGER\nr of error bounds to return for each right hand side\nach type (normwise or componentwise).  See ERR_BNDS_NORM and\nNDS_COMP below.'), ('ERR_BNDS_NORM', 'ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)\nach right-hand side, this array contains information about\nus error bounds and condition numbers corresponding to the\nise relative error, which is defined as follows:\n\nise relative error in the ith solution vector:\n   max_j (abs(XTRUE(j,i) - X(j,i)))\n  ------------------------------\n        max_j abs(X(j,i))\n\nrray is indexed by the type of error information as described\n. There currently are up to three pieces of information\nned.\n\nirst index in ERR_BNDS_NORM(i,:) corresponds to the ith\n-hand side.\n\necond index in ERR_BNDS_NORM(:,err) contains the following\n fields:\n 1 "Trust/don\'t trust" boolean. Trust the answer if the\n    reciprocal condition number is less than the threshold\n    sqrt(n) * slamch(\'Epsilon\').\n\n 2 "Guaranteed" error bound: The estimated forward error,\n    almost certainly within a factor of 10 of the true error\n    so long as the next entry is greater than the threshold\n    sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n    be trusted if the previous boolean is true.\n\n 3  Reciprocal condition number: Estimated normwise\n    reciprocal condition number.  Compared with the threshold\n    sqrt(n) * slamch(\'Epsilon\') to determine if the error\n    estimate is "guaranteed". These reciprocal condition\n    numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n    appropriately scaled matrix Z.\n    Let Z = S*A, where S scales each row by a power of the\n    radix so all absolute row sums of Z are approximately 1.\n\napack Working Note 165 for further details and extra\nons.'), ('ERR_BNDS_COMP', 'ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS)\nach right-hand side, this array contains information about\nus error bounds and condition numbers corresponding to the\nnentwise relative error, which is defined as follows:\n\nnentwise relative error in the ith solution vector:\n          abs(XTRUE(j,i) - X(j,i))\n   max_j ----------------------\n               abs(X(j,i))\n\nrray is indexed by the right-hand side i (on which the\nnentwise relative error depends), and the type of error\nmation as described below. There currently are up to three\ns of information returned for each right-hand side. If\nnentwise accuracy is not requested (PARAMS(3) = 0.0), then\nNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\nirst (:,N_ERR_BNDS) entries are returned.\n\nirst index in ERR_BNDS_COMP(i,:) corresponds to the ith\n-hand side.\n\necond index in ERR_BNDS_COMP(:,err) contains the following\n fields:\n 1 "Trust/don\'t trust" boolean. Trust the answer if the\n    reciprocal condition number is less than the threshold\n    sqrt(n) * slamch(\'Epsilon\').\n\n 2 "Guaranteed" error bound: The estimated forward error,\n    almost certainly within a factor of 10 of the true error\n    so long as the next entry is greater than the threshold\n    sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n    be trusted if the previous boolean is true.\n\n 3  Reciprocal condition number: Estimated componentwise\n    reciprocal condition number.  Compared with the threshold\n    sqrt(n) * slamch(\'Epsilon\') to determine if the error\n    estimate is "guaranteed". These reciprocal condition\n    numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n    appropriately scaled matrix Z.\n    Let Z = S*(A*diag(x)), where x is the solution for the\n    current right-hand side and S scales each row of\n    A*diag(x) by a power of the radix so all absolute row\n    sums of Z are approximately 1.\n\napack Working Note 165 for further details and extra\nons.'), ('NPARAMS', 'NPARAMS is INTEGER\nfies the number of parameters set in PARAMS.  If .LE. 0, the\nS array is never referenced and default values are used.'), ('PARAMS', 'PARAMS is REAL array, dimension NPARAMS\nfies algorithm parameters.  If an entry is .LT. 0.0, then\nentry will be filled with default value used for that\neter.  Only positions up to NPARAMS are accessed; defaults\nsed for higher-numbered parameters.\n\nAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n  refinement or not.\nefault: 1.0\n  = 0.0 : No refinement is performed, and no error bounds are\n          computed.\n  = 1.0 : Use the double-precision refinement algorithm,\n          possibly with doubled-single computations if the\n          compilation environment does not support DOUBLE\n          PRECISION.\n    (other values are reserved for future use)\n\nAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n  computations allowed for refinement.\nefault: 10\nggressive: Set to 100 to permit convergence using approximate\n           factorizations or factorizations other than LU. If\n           the factorization uses a technique other than\n           Gaussian elimination, the guarantees in\n           err_bnds_norm and err_bnds_comp may no longer be\n           trustworthy.\n\nAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n  will attempt to find a solution with small componentwise\n  relative error in the double-precision algorithm.  Positive\n  is true, 0.0 is false.\nefault: 1.0 (attempt componentwise convergence)'), ('WORK', 'WORK is REAL array, dimension (4*N)'), ('IWORK', 'IWORK is INTEGER array, dimension (N)'), ('INFO', 'INFO is INTEGER\n:  Successful exit. The solution to every right-hand side is\nuaranteed.\n:  If INFO = -i, the i-th argument had an illegal value\n and <= N:  U(INFO,INFO) is exactly zero.  The factorization\nas been completed, but the factor U is exactly singular, so\nhe solution and error bounds could not be computed. RCOND = 0\ns returned.\n+J: The solution corresponding to the Jth right-hand side is\not guaranteed. The solutions corresponding to other right-\nand sides K with K > J may not be guaranteed as well, but\nnly the first such right-hand side is reported. If a small\nomponentwise error is not requested (PARAMS(3) = 0.0) then\nhe Jth right-hand side is the first with a normwise error\nound that is not guaranteed (the smallest J such\nhat ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\nhe Jth right-hand side is the first with either a normwise or\nomponentwise error bound that is not guaranteed (the smallest\n such that either ERR_BNDS_NORM(J,1) = 0.0 or\nRR_BNDS_COMP(J,1) = 0.0). See the definition of\nRR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\nbout all of the right-hand sides check ERR_BNDS_NORM or\nRR_BNDS_COMP.'))
