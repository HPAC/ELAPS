(('dstedc', 'DSTEDC computes all eigenvalues and, optionally, eigenvectors of a\nsymmetric tridiagonal matrix using the divide and conquer method.\nThe eigenvectors of a full or band real symmetric matrix can also be\nfound if DSYTRD or DSPTRD or DSBTRD has been used to reduce this\nmatrix to tridiagonal form.\n\nThis code makes very mild assumptions about floating point\narithmetic. It will work on machines with a guard digit in\nadd/subtract, or on those binary machines without guard digits\nwhich subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.\nIt could conceivably fail on hexadecimal or decimal machines\nwithout guard digits, but we know of none.  See DLAED3 for details.'), ('COMPZ', "COMPZ is CHARACTER*1\n= 'N':  Compute eigenvalues only.\n= 'I':  Compute eigenvectors of tridiagonal matrix also.\n= 'V':  Compute eigenvectors of original dense symmetric\n        matrix also.  On entry, Z contains the orthogonal\n        matrix used to reduce the original matrix to\n        tridiagonal form."), ('N', 'N is INTEGER\nThe dimension of the symmetric tridiagonal matrix.  N >= 0.'), ('D', 'D is DOUBLE PRECISION array, dimension (N)\nOn entry, the diagonal elements of the tridiagonal matrix.\nOn exit, if INFO = 0, the eigenvalues in ascending order.'), ('E', 'E is DOUBLE PRECISION array, dimension (N-1)\nOn entry, the subdiagonal elements of the tridiagonal matrix.\nOn exit, E has been destroyed.'), ('Z', "Z is DOUBLE PRECISION array, dimension (LDZ,N)\nOn entry, if COMPZ = 'V', then Z contains the orthogonal\nmatrix used in the reduction to tridiagonal form.\nOn exit, if INFO = 0, then if COMPZ = 'V', Z contains the\northonormal eigenvectors of the original symmetric matrix,\nand if COMPZ = 'I', Z contains the orthonormal eigenvectors\nof the symmetric tridiagonal matrix.\nIf  COMPZ = 'N', then Z is not referenced."), ('LDZ', 'LDZ is INTEGER\nThe leading dimension of the array Z.  LDZ >= 1.\nIf eigenvectors are desired, then LDZ >= max(1,N).'), ('WORK', 'WORK is DOUBLE PRECISION array,\n                               dimension (LWORK)\nOn exit, if INFO = 0, WORK(1) returns the optimal LWORK.'), ('LWORK', "LWORK is INTEGER\nThe dimension of the array WORK.\nIf COMPZ = 'N' or N <= 1 then LWORK must be at least 1.\nIf COMPZ = 'V' and N > 1 then LWORK must be at least\n               ( 1 + 3*N + 2*N*lg N + 4*N**2 ),\n               where lg( N ) = smallest integer k such\n               that 2**k >= N.\nIf COMPZ = 'I' and N > 1 then LWORK must be at least\n               ( 1 + 4*N + N**2 ).\nNote that for COMPZ = 'I' or 'V', then if N is less than or\nequal to the minimum divide size, usually 25, then LWORK need\nonly be max(1,2*(N-1)).\n\nIf LWORK = -1, then a workspace query is assumed; the routine\nonly calculates the optimal size of the WORK array, returns\nthis value as the first entry of the WORK array, and no error\nmessage related to LWORK is issued by XERBLA."), ('IWORK', 'IWORK is INTEGER array, dimension (MAX(1,LIWORK))\nOn exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.'), ('LIWORK', "LIWORK is INTEGER\nThe dimension of the array IWORK.\nIf COMPZ = 'N' or N <= 1 then LIWORK must be at least 1.\nIf COMPZ = 'V' and N > 1 then LIWORK must be at least\n               ( 6 + 6*N + 5*N*lg N ).\nIf COMPZ = 'I' and N > 1 then LIWORK must be at least\n               ( 3 + 5*N ).\nNote that for COMPZ = 'I' or 'V', then if N is less than or\nequal to the minimum divide size, usually 25, then LIWORK\nneed only be 1.\n\nIf LIWORK = -1, then a workspace query is assumed; the\nroutine only calculates the optimal size of the IWORK array,\nreturns this value as the first entry of the IWORK array, and\nno error message related to LIWORK is issued by XERBLA."), ('INFO', 'INFO is INTEGER\n= 0:  successful exit.\n< 0:  if INFO = -i, the i-th argument had an illegal value.\n> 0:  The algorithm failed to compute an eigenvalue while\n      working on the submatrix lying in rows and columns\n      INFO/(N+1) through mod(INFO,N+1).'))
