(('dlasd6', 'DLASD6 computes the SVD of an updated upper bidiagonal matrix B\nobtained by merging two smaller ones by appending a row. This\nroutine is used only for the problem which requires all singular\nvalues and optionally singular vector matrices in factored form.\nB is an N-by-M matrix with N = NL + NR + 1 and M = N + SQRE.\nA related subroutine, DLASD1, handles the case in which all singular\nvalues and singular vectors of the bidiagonal matrix are desired.\n\nDLASD6 computes the SVD as follows:\n\n              ( D1(in)    0    0       0 )\n  B = U(in) * (   Z1**T   a   Z2**T    b ) * VT(in)\n              (   0       0   D2(in)   0 )\n\n    = U(out) * ( D(out) 0) * VT(out)\n\nwhere Z**T = (Z1**T a Z2**T b) = u**T VT**T, and u is a vector of dimension M\nwith ALPHA and BETA in the NL+1 and NL+2 th entries and zeros\nelsewhere; and the entry b is empty if SQRE = 0.\n\nThe singular values of B can be computed using D1, D2, the first\ncomponents of all the right singular vectors of the lower block, and\nthe last components of all the right singular vectors of the upper\nblock. These components are stored and updated in VF and VL,\nrespectively, in DLASD6. Hence U and VT are not explicitly\nreferenced.\n\nThe singular values are stored in D. The algorithm consists of two\nstages:\n\n      The first stage consists of deflating the size of the problem\n      when there are multiple singular values or if there is a zero\n      in the Z vector. For each such occurence the dimension of the\n      secular equation problem is reduced by one. This stage is\n      performed by the routine DLASD7.\n\n      The second stage consists of calculating the updated\n      singular values. This is done by finding the roots of the\n      secular equation via the routine DLASD4 (as called by DLASD8).\n      This routine also updates VF and VL and computes the distances\n      between the updated singular values and the old singular\n      values.\n\nDLASD6 is called from DLASDA.'), ('ICOMPQ', 'ICOMPQ is INTEGER\npecifies whether singular vectors are to be computed in\nactored form:\n 0: Compute singular values only.\n 1: Compute singular vectors in factored form as well.'), ('NL', 'NL is INTEGER\nhe row dimension of the upper block.  NL >= 1.'), ('NR', 'NR is INTEGER\nhe row dimension of the lower block.  NR >= 1.'), ('SQRE', 'SQRE is INTEGER\n 0: the lower block is an NR-by-NR square matrix.\n 1: the lower block is an NR-by-(NR+1) rectangular matrix.\n\nhe bidiagonal matrix has row dimension N = NL + NR + 1,\nnd column dimension M = N + SQRE.'), ('D', 'D is DOUBLE PRECISION array, dimension ( NL+NR+1 ).\nn entry D(1:NL,1:NL) contains the singular values of the\npper block, and D(NL+2:N) contains the singular values\nf the lower block. On exit D(1:N) contains the singular\nalues of the modified matrix.'), ('VF', 'VF is DOUBLE PRECISION array, dimension ( M )\nn entry, VF(1:NL+1) contains the first components of all\night singular vectors of the upper block; and VF(NL+2:M)\nontains the first components of all right singular vectors\nf the lower block. On exit, VF contains the first components\nf all right singular vectors of the bidiagonal matrix.'), ('VL', 'VL is DOUBLE PRECISION array, dimension ( M )\nn entry, VL(1:NL+1) contains the  last components of all\night singular vectors of the upper block; and VL(NL+2:M)\nontains the last components of all right singular vectors of\nhe lower block. On exit, VL contains the last components of\nll right singular vectors of the bidiagonal matrix.'), ('ALPHA', 'ALPHA is DOUBLE PRECISION\nontains the diagonal element associated with the added row.'), ('BETA', 'BETA is DOUBLE PRECISION\nontains the off-diagonal element associated with the added\now.'), ('IDXQ', 'IDXQ is INTEGER array, dimension ( N )\nhis contains the permutation which will reintegrate the\nubproblem just solved back into sorted order, i.e.\n( IDXQ( I = 1, N ) ) will be in ascending order.'), ('PERM', 'PERM is INTEGER array, dimension ( N )\nhe permutations (from deflation and sorting) to be applied\no each block. Not referenced if ICOMPQ = 0.'), ('GIVPTR', 'GIVPTR is INTEGER\nhe number of Givens rotations which took place in this\nubproblem. Not referenced if ICOMPQ = 0.'), ('GIVCOL', 'GIVCOL is INTEGER array, dimension ( LDGCOL, 2 )\nach pair of numbers indicates a pair of columns to take place\nn a Givens rotation. Not referenced if ICOMPQ = 0.'), ('LDGCOL', 'LDGCOL is INTEGER\neading dimension of GIVCOL, must be at least N.'), ('GIVNUM', 'GIVNUM is DOUBLE PRECISION array, dimension ( LDGNUM, 2 )\nach number indicates the C or S value to be used in the\norresponding Givens rotation. Not referenced if ICOMPQ = 0.'), ('LDGNUM', 'LDGNUM is INTEGER\nhe leading dimension of GIVNUM and POLES, must be at least N.'), ('POLES', 'POLES is DOUBLE PRECISION array, dimension ( LDGNUM, 2 )\nn exit, POLES(1,*) is an array containing the new singular\nalues obtained from solving the secular equation, and\nOLES(2,*) is an array containing the poles in the secular\nquation. Not referenced if ICOMPQ = 0.'), ('DIFL', 'DIFL is DOUBLE PRECISION array, dimension ( N )\nn exit, DIFL(I) is the distance between I-th updated\nundeflated) singular value and the I-th (undeflated) old\ningular value.'), ('DIFR', 'DIFR is DOUBLE PRECISION array,\n        dimension ( LDGNUM, 2 ) if ICOMPQ = 1 and\n        dimension ( N ) if ICOMPQ = 0.\nn exit, DIFR(I, 1) is the distance between I-th updated\nundeflated) singular value and the I+1-th (undeflated) old\ningular value.\n\nf ICOMPQ = 1, DIFR(1:K,2) is an array containing the\normalizing factors for the right singular vector matrix.\n\nee DLASD8 for details on DIFL and DIFR.'), ('Z', 'Z is DOUBLE PRECISION array, dimension ( M )\nhe first elements of this array contain the components\nf the deflation-adjusted updating row vector.'), ('K', 'K is INTEGER\nontains the dimension of the non-deflated matrix,\nhis is the order of the related secular equation. 1 <= K <=N.'), ('C', 'C is DOUBLE PRECISION\n contains garbage if SQRE =0 and the C-value of a Givens\notation related to the right null space if SQRE = 1.'), ('S', 'S is DOUBLE PRECISION\n contains garbage if SQRE =0 and the S-value of a Givens\notation related to the right null space if SQRE = 1.'), ('WORK', 'WORK is DOUBLE PRECISION array, dimension ( 4 * M )'), ('IWORK', 'IWORK is INTEGER array, dimension ( 3 * N )'), ('INFO', 'INFO is INTEGER\n= 0:  successful exit.\n< 0:  if INFO = -i, the i-th argument had an illegal value.\n> 0:  if INFO = 1, a singular value did not converge'))
