(('sgelsd', 'SGELSD computes the minimum-norm solution to a real linear least\nsquares problem:\n    minimize 2-norm(| b - A*x |)\nusing the singular value decomposition (SVD) of A. A is an M-by-N\nmatrix which may be rank-deficient.\n\nSeveral right hand side vectors b and solution vectors x can be\nhandled in a single call; they are stored as the columns of the\nM-by-NRHS right hand side matrix B and the N-by-NRHS solution\nmatrix X.\n\nThe problem is solved in three steps:\n(1) Reduce the coefficient matrix A to bidiagonal form with\n    Householder transformations, reducing the original problem\n    into a "bidiagonal least squares problem" (BLS)\n(2) Solve the BLS using a divide and conquer approach.\n(3) Apply back all the Householder tranformations to solve\n    the original least squares problem.\n\nThe effective rank of A is determined by treating as zero those\nsingular values which are less than RCOND times the largest singular\nvalue.\n\nThe divide and conquer algorithm makes very mild assumptions about\nfloating point arithmetic. It will work on machines with a guard\ndigit in add/subtract, or on those binary machines without guard\ndigits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or\nCray-2. It could conceivably fail on hexadecimal or decimal machines\nwithout guard digits, but we know of none.'), ('M', 'M is INTEGER\nThe number of rows of A. M >= 0.'), ('N', 'N is INTEGER\nThe number of columns of A. N >= 0.'), ('NRHS', 'NRHS is INTEGER\nThe number of right hand sides, i.e., the number of columns\nof the matrices B and X. NRHS >= 0.'), ('A', 'A is REAL array, dimension (LDA,N)\nOn entry, the M-by-N matrix A.\nOn exit, A has been destroyed.'), ('LDA', 'LDA is INTEGER\nThe leading dimension of the array A.  LDA >= max(1,M).'), ('B', 'B is REAL array, dimension (LDB,NRHS)\nOn entry, the M-by-NRHS right hand side matrix B.\nOn exit, B is overwritten by the N-by-NRHS solution\nmatrix X.  If m >= n and RANK = n, the residual\nsum-of-squares for the solution in the i-th column is given\nby the sum of squares of elements n+1:m in that column.'), ('LDB', 'LDB is INTEGER\nThe leading dimension of the array B. LDB >= max(1,max(M,N)).'), ('S', 'S is REAL array, dimension (min(M,N))\nThe singular values of A in decreasing order.\nThe condition number of A in the 2-norm = S(1)/S(min(m,n)).'), ('RCOND', 'RCOND is REAL\nRCOND is used to determine the effective rank of A.\nSingular values S(i) <= RCOND*S(1) are treated as zero.\nIf RCOND < 0, machine precision is used instead.'), ('RANK', 'RANK is INTEGER\nThe effective rank of A, i.e., the number of singular values\nwhich are greater than RCOND*S(1).'), ('WORK', 'WORK is REAL array, dimension (MAX(1,LWORK))\nOn exit, if INFO = 0, WORK(1) returns the optimal LWORK.'), ('LWORK', 'LWORK is INTEGER\nThe dimension of the array WORK. LWORK must be at least 1.\nThe exact minimum amount of workspace needed depends on M,\nN and NRHS. As long as LWORK is at least\n    12*N + 2*N*SMLSIZ + 8*N*NLVL + N*NRHS + (SMLSIZ+1)**2,\nif M is greater than or equal to N or\n    12*M + 2*M*SMLSIZ + 8*M*NLVL + M*NRHS + (SMLSIZ+1)**2,\nif M is less than N, the code will execute correctly.\nSMLSIZ is returned by ILAENV and is equal to the maximum\nsize of the subproblems at the bottom of the computation\ntree (usually about 25), and\n   NLVL = MAX( 0, INT( LOG_2( MIN( M,N )/(SMLSIZ+1) ) ) + 1 )\nFor good performance, LWORK should generally be larger.\n\nIf LWORK = -1, then a workspace query is assumed; the routine\nonly calculates the optimal size of the array WORK and the\nminimum size of the array IWORK, and returns these values as\nthe first entries of the WORK and IWORK arrays, and no error\nmessage related to LWORK is issued by XERBLA.'), ('IWORK', 'IWORK is INTEGER array, dimension (MAX(1,LIWORK))\nLIWORK >= max(1, 3*MINMN*NLVL + 11*MINMN),\nwhere MINMN = MIN( M,N ).\nOn exit, if INFO = 0, IWORK(1) returns the minimum LIWORK.'), ('INFO', 'INFO is INTEGER\n= 0:  successful exit\n< 0:  if INFO = -i, the i-th argument had an illegal value.\n> 0:  the algorithm for computing the SVD failed to converge;\n      if INFO = i, i off-diagonal elements of an intermediate\n      bidiagonal form did not converge to zero.'))
