(('dlasq2', "DLASQ2 computes all the eigenvalues of the symmetric positive \ndefinite tridiagonal matrix associated with the qd array Z to high\nrelative accuracy are computed to high relative accuracy, in the\nabsence of denormalization, underflow and overflow.\n\nTo see the relation of Z to the tridiagonal matrix, let L be a\nunit lower bidiagonal matrix with subdiagonals Z(2,4,6,,..) and\nlet U be an upper bidiagonal matrix with 1's above and diagonal\nZ(1,3,5,,..). The tridiagonal is L*U or, if you prefer, the\nsymmetric tridiagonal to which it is similar.\n\nNote : DLASQ2 defines a logical variable, IEEE, which is true\non machines which follow ieee-754 floating-point standard in their\nhandling of infinities and NaNs, and false otherwise. This variable\nis passed to DLASQ3."), ('N', 'N is INTEGER\ne number of rows and columns in the matrix. N >= 0.'), ('Z', 'Z is DOUBLE PRECISION array, dimension ( 4*N )\n entry Z holds the qd array. On exit, entries 1 to N hold\ne eigenvalues in decreasing order, Z( 2*N+1 ) holds the\nace, and Z( 2*N+2 ) holds the sum of the eigenvalues. If\n> 2, then Z( 2*N+3 ) holds the iteration count, Z( 2*N+4 )\nlds NDIVS/NIN^2, and Z( 2*N+5 ) holds the percentage of\nifts that failed.'), ('INFO', 'INFO is INTEGER\n0: successful exit\n0: if the i-th argument is a scalar and had an illegal\n   value, then INFO = -i, if the i-th argument is an\n   array and the j-entry had an illegal value, then\n   INFO = -(i*100+j)\n0: the algorithm failed\n    = 1, a split was marked by a positive value in E\n    = 2, current block of Z not diagonalized after 100*N\n         iterations (in inner while loop).  On exit Z holds\n         a qd array with the same eigenvalues as the given Z.\n    = 3, termination criterion of outer while loop not met \n         (program created more than N unreduced blocks)'))
