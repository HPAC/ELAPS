(('dlasd1', 'DLASD1 computes the SVD of an upper bidiagonal N-by-M matrix B,\nwhere N = NL + NR + 1 and M = N + SQRE. DLASD1 is called from DLASD0.\n\nA related subroutine DLASD7 handles the case in which the singular\nvalues (and the singular vectors in factored form) are desired.\n\nDLASD1 computes the SVD as follows:\n\n              ( D1(in)    0    0       0 )\n  B = U(in) * (   Z1**T   a   Z2**T    b ) * VT(in)\n              (   0       0   D2(in)   0 )\n\n    = U(out) * ( D(out) 0) * VT(out)\n\nwhere Z**T = (Z1**T a Z2**T b) = u**T VT**T, and u is a vector of dimension M\nwith ALPHA and BETA in the NL+1 and NL+2 th entries and zeros\nelsewhere; and the entry b is empty if SQRE = 0.\n\nThe left singular vectors of the original matrix are stored in U, and\nthe transpose of the right singular vectors are stored in VT, and the\nsingular values are in D.  The algorithm consists of three stages:\n\n   The first stage consists of deflating the size of the problem\n   when there are multiple singular values or when there are zeros in\n   the Z vector.  For each such occurence the dimension of the\n   secular equation problem is reduced by one.  This stage is\n   performed by the routine DLASD2.\n\n   The second stage consists of calculating the updated\n   singular values. This is done by finding the square roots of the\n   roots of the secular equation via the routine DLASD4 (as called\n   by DLASD3). This routine also calculates the singular vectors of\n   the current problem.\n\n   The final stage consists of computing the updated singular vectors\n   directly using the updated singular values.  The singular vectors\n   for the current problem are multiplied with the singular vectors\n   from the overall problem.'), ('NL', 'NL is INTEGER\nhe row dimension of the upper block.  NL >= 1.'), ('NR', 'NR is INTEGER\nhe row dimension of the lower block.  NR >= 1.'), ('SQRE', 'SQRE is INTEGER\n 0: the lower block is an NR-by-NR square matrix.\n 1: the lower block is an NR-by-(NR+1) rectangular matrix.\n\nhe bidiagonal matrix has row dimension N = NL + NR + 1,\nnd column dimension M = N + SQRE.'), ('D', 'D is DOUBLE PRECISION array,\n              dimension (N = NL+NR+1).\nn entry D(1:NL,1:NL) contains the singular values of the\npper block; and D(NL+2:N) contains the singular values of\nhe lower block. On exit D(1:N) contains the singular values\nf the modified matrix.'), ('ALPHA', 'ALPHA is DOUBLE PRECISION\nontains the diagonal element associated with the added row.'), ('BETA', 'BETA is DOUBLE PRECISION\nontains the off-diagonal element associated with the added\now.'), ('U', 'U is DOUBLE PRECISION array, dimension(LDU,N)\nn entry U(1:NL, 1:NL) contains the left singular vectors of\nhe upper block; U(NL+2:N, NL+2:N) contains the left singular\nectors of the lower block. On exit U contains the left\ningular vectors of the bidiagonal matrix.'), ('LDU', 'LDU is INTEGER\nhe leading dimension of the array U.  LDU >= max( 1, N ).'), ('VT', 'VT is DOUBLE PRECISION array, dimension(LDVT,M)\nhere M = N + SQRE.\nn entry VT(1:NL+1, 1:NL+1)**T contains the right singular\nectors of the upper block; VT(NL+2:M, NL+2:M)**T contains\nhe right singular vectors of the lower block. On exit\nT**T contains the right singular vectors of the\nidiagonal matrix.'), ('LDVT', 'LDVT is INTEGER\nhe leading dimension of the array VT.  LDVT >= max( 1, M ).'), ('IDXQ', 'IDXQ is INTEGER array, dimension(N)\nhis contains the permutation which will reintegrate the\nubproblem just solved back into sorted order, i.e.\n( IDXQ( I = 1, N ) ) will be in ascending order.'), ('IWORK', 'IWORK is INTEGER array, dimension( 4 * N )'), ('WORK', 'WORK is DOUBLE PRECISION array, dimension( 3*M**2 + 2*M )'), ('INFO', 'INFO is INTEGER\n= 0:  successful exit.\n< 0:  if INFO = -i, the i-th argument had an illegal value.\n> 0:  if INFO = 1, a singular value did not converge'))
