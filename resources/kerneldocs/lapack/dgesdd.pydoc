(('dgesdd', 'DGESDD computes the singular value decomposition (SVD) of a real\nM-by-N matrix A, optionally computing the left and right singular\nvectors.  If singular vectors are desired, it uses a\ndivide-and-conquer algorithm.\n\nThe SVD is written\n\n     A = U * SIGMA * transpose(V)\n\nwhere SIGMA is an M-by-N matrix which is zero except for its\nmin(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and\nV is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA\nare the singular values of A; they are real and non-negative, and\nare returned in descending order.  The first min(m,n) columns of\nU and V are the left and right singular vectors of A.\n\nNote that the routine returns VT = V**T, not V.\n\nThe divide and conquer algorithm makes very mild assumptions about\nfloating point arithmetic. It will work on machines with a guard\ndigit in add/subtract, or on those binary machines without guard\ndigits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or\nCray-2. It could conceivably fail on hexadecimal or decimal machines\nwithout guard digits, but we know of none.'), ('JOBZ', "JOBZ is CHARACTER*1\nSpecifies options for computing all or part of the matrix U:\n= 'A':  all M columns of U and all N rows of V**T are\n        returned in the arrays U and VT;\n= 'S':  the first min(M,N) columns of U and the first\n        min(M,N) rows of V**T are returned in the arrays U\n        and VT;\n= 'O':  If M >= N, the first N columns of U are overwritten\n        on the array A and all rows of V**T are returned in\n        the array VT;\n        otherwise, all columns of U are returned in the\n        array U and the first M rows of V**T are overwritten\n        in the array A;\n= 'N':  no columns of U or rows of V**T are computed."), ('M', 'M is INTEGER\nThe number of rows of the input matrix A.  M >= 0.'), ('N', 'N is INTEGER\nThe number of columns of the input matrix A.  N >= 0.'), ('A', "A is DOUBLE PRECISION array, dimension (LDA,N)\nOn entry, the M-by-N matrix A.\nOn exit,\nif JOBZ = 'O',  A is overwritten with the first N columns\n                of U (the left singular vectors, stored\n                columnwise) if M >= N;\n                A is overwritten with the first M rows\n                of V**T (the right singular vectors, stored\n                rowwise) otherwise.\nif JOBZ .ne. 'O', the contents of A are destroyed."), ('LDA', 'LDA is INTEGER\nThe leading dimension of the array A.  LDA >= max(1,M).'), ('S', 'S is DOUBLE PRECISION array, dimension (min(M,N))\nThe singular values of A, sorted so that S(i) >= S(i+1).'), ('U', "U is DOUBLE PRECISION array, dimension (LDU,UCOL)\nUCOL = M if JOBZ = 'A' or JOBZ = 'O' and M < N;\nUCOL = min(M,N) if JOBZ = 'S'.\nIf JOBZ = 'A' or JOBZ = 'O' and M < N, U contains the M-by-M\northogonal matrix U;\nif JOBZ = 'S', U contains the first min(M,N) columns of U\n(the left singular vectors, stored columnwise);\nif JOBZ = 'O' and M >= N, or JOBZ = 'N', U is not referenced."), ('LDU', "LDU is INTEGER\nThe leading dimension of the array U.  LDU >= 1; if\nJOBZ = 'S' or 'A' or JOBZ = 'O' and M < N, LDU >= M."), ('VT', "VT is DOUBLE PRECISION array, dimension (LDVT,N)\nIf JOBZ = 'A' or JOBZ = 'O' and M >= N, VT contains the\nN-by-N orthogonal matrix V**T;\nif JOBZ = 'S', VT contains the first min(M,N) rows of\nV**T (the right singular vectors, stored rowwise);\nif JOBZ = 'O' and M < N, or JOBZ = 'N', VT is not referenced."), ('LDVT', "LDVT is INTEGER\nThe leading dimension of the array VT.  LDVT >= 1; if\nJOBZ = 'A' or JOBZ = 'O' and M >= N, LDVT >= N;\nif JOBZ = 'S', LDVT >= min(M,N)."), ('WORK', 'WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))\nOn exit, if INFO = 0, WORK(1) returns the optimal LWORK;'), ('LWORK', "LWORK is INTEGER\nThe dimension of the array WORK. LWORK >= 1.\nIf JOBZ = 'N',\n  LWORK >= 3*min(M,N) + max(max(M,N),7*min(M,N)).\nIf JOBZ = 'O',\n  LWORK >= 3*min(M,N) + \n           max(max(M,N),5*min(M,N)*min(M,N)+4*min(M,N)).\nIf JOBZ = 'S' or 'A'\n  LWORK >= min(M,N)*(7+4*min(M,N))\nFor good performance, LWORK should generally be larger.\nIf LWORK = -1 but other input arguments are legal, WORK(1)\nreturns the optimal LWORK."), ('IWORK', 'IWORK is INTEGER array, dimension (8*min(M,N))'), ('INFO', 'INFO is INTEGER\n= 0:  successful exit.\n< 0:  if INFO = -i, the i-th argument had an illegal value.\n> 0:  DBDSDC did not converge, updating process failed.'))
