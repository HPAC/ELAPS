(('sgejsv', 'SGEJSV computes the singular value decomposition (SVD) of a real M-by-N\nmatrix [A], where M >= N. The SVD of [A] is written as\n\n             [A] = [U] * [SIGMA] * [V]^t,\n\nwhere [SIGMA] is an N-by-N (M-by-N) matrix which is zero except for its N\ndiagonal elements, [U] is an M-by-N (or M-by-M) orthonormal matrix, and\n[V] is an N-by-N orthogonal matrix. The diagonal elements of [SIGMA] are\nthe singular values of [A]. The columns of [U] and [V] are the left and\nthe right singular vectors of [A], respectively. The matrices [U] and [V]\nare computed and stored in the arrays U and V, respectively. The diagonal\nof [SIGMA] is computed and stored in the array SVA.\nSGEJSV can sometimes compute tiny singular values and their singular vectors much\nmore accurately than other SVD routines, see below under Further Details.  '), ('JOBA', "JOBA is CHARACTER*1\npecifies the level of accuracy:\nC': This option works well (high relative accuracy) if A = B * D,\n    with well-conditioned B and arbitrary diagonal matrix D.\n    The accuracy cannot be spoiled by COLUMN scaling. The\n    accuracy of the computed output depends on the condition of\n    B, and the procedure aims at the best theoretical accuracy.\n    The relative error max_{i=1:N}|d sigma_i| / sigma_i is\n    bounded by f(M,N)*epsilon* cond(B), independent of D.\n    The input matrix is preprocessed with the QRF with column\n    pivoting. This initial preprocessing and preconditioning by\n    a rank revealing QR factorization is common for all values of\n    JOBA. Additional actions are specified as follows:\nE': Computation as with 'C' with an additional estimate of the\n    condition number of B. It provides a realistic error bound.\nF': If A = D1 * C * D2 with ill-conditioned diagonal scalings\n    D1, D2, and well-conditioned matrix C, this option gives\n    higher accuracy than the 'C' option. If the structure of the\n    input matrix is not known, and relative accuracy is\n    desirable, then this option is advisable. The input matrix A\n    is preprocessed with QR factorization with FULL (row and\n    column) pivoting.\nG'  Computation as with 'F' with an additional estimate of the\n    condition number of B, where A=D*B. If A has heavily weighted\n    rows, then using this condition number gives too pessimistic\n    error bound.\nA': Small singular values are the noise and the matrix is treated\n    as numerically rank defficient. The error in the computed\n    singular values is bounded by f(m,n)*epsilon*||A||.\n    The computed SVD A = U * S * V^t restores A up to\n    f(m,n)*epsilon*||A||.\n    This gives the procedure the licence to discard (set to zero)\n    all singular values below N*epsilon*||A||.\nR': Similar as in 'A'. Rank revealing property of the initial\n    QR factorization is used do reveal (using triangular factor)\n    a gap sigma_{r+1} < epsilon * sigma_r in which case the\n    numerical RANK is declared to be r. The SVD is computed with\n    absolute error bounds, but more accurately than with 'A'."), ('JOBU', "JOBU is CHARACTER*1\npecifies whether to compute the columns of U:\nU': N columns of U are returned in the array U.\nF': full set of M left sing. vectors is returned in the array U.\nW': U may be used as workspace of length M*N. See the description\n    of U.\nN': U is not computed."), ('JOBV', "JOBV is CHARACTER*1\npecifies whether to compute the matrix V:\nV': N columns of V are returned in the array V; Jacobi rotations\n    are not explicitly accumulated.\nJ': N columns of V are returned in the array V, but they are\n    computed as the product of Jacobi rotations. This option is\n    allowed only if JOBU .NE. 'N', i.e. in computing the full SVD.\nW': V may be used as workspace of length N*N. See the description\n    of V.\nN': V is not computed."), ('JOBR', "JOBR is CHARACTER*1\npecifies the RANGE for the singular values. Issues the licence to\net to zero small positive singular values if they are outside\npecified range. If A .NE. 0 is scaled so that the largest singular\nalue of c*A is around SQRT(BIG), BIG=SLAMCH('O'), then JOBR issues\nhe licence to kill columns of A whose norm in c*A is less than\nQRT(SFMIN) (for JOBR.EQ.'R'), or less than SMALL=SFMIN/EPSLN,\nhere SFMIN=SLAMCH('S'), EPSLN=SLAMCH('E').\nN': Do not kill small columns of c*A. This option assumes that\n    BLAS and QR factorizations and triangular solvers are\n    implemented to work in that range. If the condition of A\n    is greater than BIG, use SGESVJ.\nR': RESTRICTED range for sigma(c*A) is [SQRT(SFMIN), SQRT(BIG)]\n    (roughly, as described above). This option is recommended.\n                                   ===========================\nor computing the singular values in the FULL range [SFMIN,BIG]\nse SGESVJ."), ('JOBT', "JOBT is CHARACTER*1\nf the matrix is square then the procedure may determine to use\nransposed A if A^t seems to be better with respect to convergence.\nf the matrix is not square, JOBT is ignored. This is subject to\nhanges in the future.\nhe decision is based on two values of entropy over the adjoint\nrbit of A^t * A. See the descriptions of WORK(6) and WORK(7).\nT': transpose if entropy test indicates possibly faster\nonvergence of Jacobi process if A^t is taken as input. If A is\neplaced with A^t, then the row pivoting is included automatically.\nN': do not speculate.\nhis option can be used to compute only the singular values, or the\null SVD (U, SIGMA and V). For only one set of singular vectors\nU or V), the caller should provide both U and V, as one of the\natrices is used as workspace if the matrix A is transposed.\nhe implementer can easily remove this constraint and make the\node more complicated. See the descriptions of U and V."), ('JOBP', "JOBP is CHARACTER*1\nssues the licence to introduce structured perturbations to drown\nenormalized numbers. This licence should be active if the\nenormals are poorly implemented, causing slow computation,\nspecially in cases of fast convergence (!). For details see [1,2].\nor the sake of simplicity, this perturbations are included only\nhen the full SVD or only the singular values are requested. The\nmplementer/user can easily add the perturbation for the cases of\nomputing one set of singular vectors.\nP': introduce perturbation\nN': do not perturb"), ('M', 'M is INTEGER\nhe number of rows of the input matrix A.  M >= 0.'), ('N', 'N is INTEGER\nhe number of columns of the input matrix A. M >= N >= 0.'), ('A', 'A is REAL array, dimension (LDA,N)\nOn entry, the M-by-N matrix A.'), ('LDA', 'LDA is INTEGER\nThe leading dimension of the array A.  LDA >= max(1,M).'), ('SVA', 'SVA is REAL array, dimension (N)\nOn exit,\n- For WORK(1)/WORK(2) = ONE: The singular values of A. During the\n  computation SVA contains Euclidean column norms of the\n  iterated matrices in the array A.\n- For WORK(1) .NE. WORK(2): The singular values of A are\n  (WORK(1)/WORK(2)) * SVA(1:N). This factored form is used if\n  sigma_max(A) overflows or if small singular values have been\n  saved from underflow by scaling the input matrix A.\n- If JOBR=\'R\' then some of the singular values may be returned\n  as exact zeros obtained by "set to zero" because they are\n  below the numerical rank threshold or are denormalized numbers.'), ('U', "U is REAL array, dimension ( LDU, N )\nIf JOBU = 'U', then U contains on exit the M-by-N matrix of\n               the left singular vectors.\nIf JOBU = 'F', then U contains on exit the M-by-M matrix of\n               the left singular vectors, including an ONB\n               of the orthogonal complement of the Range(A).\nIf JOBU = 'W'  .AND. (JOBV.EQ.'V' .AND. JOBT.EQ.'T' .AND. M.EQ.N),\n               then U is used as workspace if the procedure\n               replaces A with A^t. In that case, [V] is computed\n               in U as left singular vectors of A^t and then\n               copied back to the V array. This 'W' option is just\n               a reminder to the caller that in this case U is\n               reserved as workspace of length N*N.\nIf JOBU = 'N'  U is not referenced."), ('LDU', "LDU is INTEGER\nThe leading dimension of the array U,  LDU >= 1.\nIF  JOBU = 'U' or 'F' or 'W',  then LDU >= M."), ('V', "V is REAL array, dimension ( LDV, N )\nIf JOBV = 'V', 'J' then V contains on exit the N-by-N matrix of\n               the right singular vectors;\nIf JOBV = 'W', AND (JOBU.EQ.'U' AND JOBT.EQ.'T' AND M.EQ.N),\n               then V is used as workspace if the pprocedure\n               replaces A with A^t. In that case, [U] is computed\n               in V as right singular vectors of A^t and then\n               copied back to the U array. This 'W' option is just\n               a reminder to the caller that in this case V is\n               reserved as workspace of length N*N.\nIf JOBV = 'N'  V is not referenced."), ('LDV', "LDV is INTEGER\nThe leading dimension of the array V,  LDV >= 1.\nIf JOBV = 'V' or 'J' or 'W', then LDV >= N."), ('WORK', "WORK is REAL array, dimension at least LWORK.\nOn exit,\nWORK(1) = SCALE = WORK(2) / WORK(1) is the scaling factor such\n          that SCALE*SVA(1:N) are the computed singular values\n          of A. (See the description of SVA().)\nWORK(2) = See the description of WORK(1).\nWORK(3) = SCONDA is an estimate for the condition number of\n          column equilibrated A. (If JOBA .EQ. 'E' or 'G')\n          SCONDA is an estimate of SQRT(||(R^t * R)^(-1)||_1).\n          It is computed using SPOCON. It holds\n          N^(-1/4) * SCONDA <= ||R^(-1)||_2 <= N^(1/4) * SCONDA\n          where R is the triangular factor from the QRF of A.\n          However, if R is truncated and the numerical rank is\n          determined to be strictly smaller than N, SCONDA is\n          returned as -1, thus indicating that the smallest\n          singular values might be lost.\n\nIf full SVD is needed, the following two condition numbers are\nuseful for the analysis of the algorithm. They are provied for\na developer/implementer who is familiar with the details of\nthe method.\n\nWORK(4) = an estimate of the scaled condition number of the\n          triangular factor in the first QR factorization.\nWORK(5) = an estimate of the scaled condition number of the\n          triangular factor in the second QR factorization.\nThe following two parameters are computed if JOBT .EQ. 'T'.\nThey are provided for a developer/implementer who is familiar\nwith the details of the method.\n\nWORK(6) = the entropy of A^t*A :: this is the Shannon entropy\n          of diag(A^t*A) / Trace(A^t*A) taken as point in the\n          probability simplex.\nWORK(7) = the entropy of A*A^t."), ('LWORK', "LWORK is INTEGER\nLength of WORK to confirm proper allocation of work space.\nLWORK depends on the job:\n\nIf only SIGMA is needed ( JOBU.EQ.'N', JOBV.EQ.'N' ) and\n  -> .. no scaled condition estimate required (JOBE.EQ.'N'):\n     LWORK >= max(2*M+N,4*N+1,7). This is the minimal requirement.\n     ->> For optimal performance (blocked code) the optimal value\n     is LWORK >= max(2*M+N,3*N+(N+1)*NB,7). Here NB is the optimal\n     block size for DGEQP3 and DGEQRF.\n     In general, optimal LWORK is computed as \n     LWORK >= max(2*M+N,N+LWORK(DGEQP3),N+LWORK(DGEQRF), 7).        \n  -> .. an estimate of the scaled condition number of A is\n     required (JOBA='E', 'G'). In this case, LWORK is the maximum\n     of the above and N*N+4*N, i.e. LWORK >= max(2*M+N,N*N+4*N,7).\n     ->> For optimal performance (blocked code) the optimal value \n     is LWORK >= max(2*M+N,3*N+(N+1)*NB, N*N+4*N, 7).\n     In general, the optimal length LWORK is computed as\n     LWORK >= max(2*M+N,N+LWORK(DGEQP3),N+LWORK(DGEQRF), \n                                           N+N*N+LWORK(DPOCON),7).\n\nIf SIGMA and the right singular vectors are needed (JOBV.EQ.'V'),\n  -> the minimal requirement is LWORK >= max(2*M+N,4*N+1,7).\n  -> For optimal performance, LWORK >= max(2*M+N,3*N+(N+1)*NB,7),\n     where NB is the optimal block size for DGEQP3, DGEQRF, DGELQ,\n     DORMLQ. In general, the optimal length LWORK is computed as\n     LWORK >= max(2*M+N,N+LWORK(DGEQP3), N+LWORK(DPOCON), \n             N+LWORK(DGELQ), 2*N+LWORK(DGEQRF), N+LWORK(DORMLQ)).\n\nIf SIGMA and the left singular vectors are needed\n  -> the minimal requirement is LWORK >= max(2*M+N,4*N+1,7).\n  -> For optimal performance:\n     if JOBU.EQ.'U' :: LWORK >= max(2*M+N,3*N+(N+1)*NB,7),\n     if JOBU.EQ.'F' :: LWORK >= max(2*M+N,3*N+(N+1)*NB,N+M*NB,7),\n     where NB is the optimal block size for DGEQP3, DGEQRF, DORMQR.\n     In general, the optimal length LWORK is computed as\n     LWORK >= max(2*M+N,N+LWORK(DGEQP3),N+LWORK(DPOCON),\n              2*N+LWORK(DGEQRF), N+LWORK(DORMQR)). \n     Here LWORK(DORMQR) equals N*NB (for JOBU.EQ.'U') or \n     M*NB (for JOBU.EQ.'F').\n     \nIf the full SVD is needed: (JOBU.EQ.'U' or JOBU.EQ.'F') and \n  -> if JOBV.EQ.'V'  \n     the minimal requirement is LWORK >= max(2*M+N,6*N+2*N*N). \n  -> if JOBV.EQ.'J' the minimal requirement is \n     LWORK >= max(2*M+N, 4*N+N*N,2*N+N*N+6).\n  -> For optimal performance, LWORK should be additionally\n     larger than N+M*NB, where NB is the optimal block size\n     for DORMQR."), ('IWORK', 'IWORK is INTEGER array, dimension M+3*N.\nOn exit,\nIWORK(1) = the numerical rank determined after the initial\n           QR factorization with pivoting. See the descriptions\n           of JOBA and JOBR.\nIWORK(2) = the number of the computed nonzero singular values\nIWORK(3) = if nonzero, a warning message:\n           If IWORK(3).EQ.1 then some of the column norms of A\n           were denormalized floats. The requested high accuracy\n           is not warranted by the data.'), ('INFO', 'INFO is INTEGER\n < 0  : if INFO = -i, then the i-th argument had an illegal value.\n = 0 :  successfull exit;\n > 0 :  SGEJSV  did not converge in the maximal allowed number\n        of sweeps. The computed values may be inaccurate.'))
