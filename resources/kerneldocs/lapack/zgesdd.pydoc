(('zgesdd', 'ZGESDD computes the singular value decomposition (SVD) of a complex\nM-by-N matrix A, optionally computing the left and/or right singular\nvectors, by using divide-and-conquer method. The SVD is written\n\n     A = U * SIGMA * conjugate-transpose(V)\n\nwhere SIGMA is an M-by-N matrix which is zero except for its\nmin(m,n) diagonal elements, U is an M-by-M unitary matrix, and\nV is an N-by-N unitary matrix.  The diagonal elements of SIGMA\nare the singular values of A; they are real and non-negative, and\nare returned in descending order.  The first min(m,n) columns of\nU and V are the left and right singular vectors of A.\n\nNote that the routine returns VT = V**H, not V.\n\nThe divide and conquer algorithm makes very mild assumptions about\nfloating point arithmetic. It will work on machines with a guard\ndigit in add/subtract, or on those binary machines without guard\ndigits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or\nCray-2. It could conceivably fail on hexadecimal or decimal machines\nwithout guard digits, but we know of none.'), ('JOBZ', "JOBZ is CHARACTER*1\nSpecifies options for computing all or part of the matrix U:\n= 'A':  all M columns of U and all N rows of V**H are\n        returned in the arrays U and VT;\n= 'S':  the first min(M,N) columns of U and the first\n        min(M,N) rows of V**H are returned in the arrays U\n        and VT;\n= 'O':  If M >= N, the first N columns of U are overwritten\n        in the array A and all rows of V**H are returned in\n        the array VT;\n        otherwise, all columns of U are returned in the\n        array U and the first M rows of V**H are overwritten\n        in the array A;\n= 'N':  no columns of U or rows of V**H are computed."), ('M', 'M is INTEGER\nThe number of rows of the input matrix A.  M >= 0.'), ('N', 'N is INTEGER\nThe number of columns of the input matrix A.  N >= 0.'), ('A', "A is COMPLEX*16 array, dimension (LDA,N)\nOn entry, the M-by-N matrix A.\nOn exit,\nif JOBZ = 'O',  A is overwritten with the first N columns\n                of U (the left singular vectors, stored\n                columnwise) if M >= N;\n                A is overwritten with the first M rows\n                of V**H (the right singular vectors, stored\n                rowwise) otherwise.\nif JOBZ .ne. 'O', the contents of A are destroyed."), ('LDA', 'LDA is INTEGER\nThe leading dimension of the array A.  LDA >= max(1,M).'), ('S', 'S is DOUBLE PRECISION array, dimension (min(M,N))\nThe singular values of A, sorted so that S(i) >= S(i+1).'), ('U', "U is COMPLEX*16 array, dimension (LDU,UCOL)\nUCOL = M if JOBZ = 'A' or JOBZ = 'O' and M < N;\nUCOL = min(M,N) if JOBZ = 'S'.\nIf JOBZ = 'A' or JOBZ = 'O' and M < N, U contains the M-by-M\nunitary matrix U;\nif JOBZ = 'S', U contains the first min(M,N) columns of U\n(the left singular vectors, stored columnwise);\nif JOBZ = 'O' and M >= N, or JOBZ = 'N', U is not referenced."), ('LDU', "LDU is INTEGER\nThe leading dimension of the array U.  LDU >= 1; if\nJOBZ = 'S' or 'A' or JOBZ = 'O' and M < N, LDU >= M."), ('VT', "VT is COMPLEX*16 array, dimension (LDVT,N)\nIf JOBZ = 'A' or JOBZ = 'O' and M >= N, VT contains the\nN-by-N unitary matrix V**H;\nif JOBZ = 'S', VT contains the first min(M,N) rows of\nV**H (the right singular vectors, stored rowwise);\nif JOBZ = 'O' and M < N, or JOBZ = 'N', VT is not referenced."), ('LDVT', "LDVT is INTEGER\nThe leading dimension of the array VT.  LDVT >= 1; if\nJOBZ = 'A' or JOBZ = 'O' and M >= N, LDVT >= N;\nif JOBZ = 'S', LDVT >= min(M,N)."), ('WORK', 'WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))\nOn exit, if INFO = 0, WORK(1) returns the optimal LWORK.'), ('LWORK', "LWORK is INTEGER\nThe dimension of the array WORK. LWORK >= 1.\nif JOBZ = 'N', LWORK >= 2*min(M,N)+max(M,N).\nif JOBZ = 'O',\n      LWORK >= 2*min(M,N)*min(M,N)+2*min(M,N)+max(M,N).\nif JOBZ = 'S' or 'A',\n      LWORK >= min(M,N)*min(M,N)+2*min(M,N)+max(M,N).\nFor good performance, LWORK should generally be larger.\n\nIf LWORK = -1, a workspace query is assumed.  The optimal\nsize for the WORK array is calculated and stored in WORK(1),\nand no other work except argument checking is performed."), ('RWORK', "RWORK is DOUBLE PRECISION array, dimension (MAX(1,LRWORK))\nIf JOBZ = 'N', LRWORK >= 5*min(M,N).\nOtherwise,\nLRWORK >= min(M,N)*max(5*min(M,N)+7,2*max(M,N)+2*min(M,N)+1)"), ('IWORK', 'IWORK is INTEGER array, dimension (8*min(M,N))'), ('INFO', 'INFO is INTEGER\n= 0:  successful exit.\n< 0:  if INFO = -i, the i-th argument had an illegal value.\n> 0:  The updating process of DBDSDC did not converge.'))
