(('zunmbr', "If VECT = 'Q', ZUNMBR overwrites the general complex M-by-N matrix C\nwith\n                SIDE = 'L'     SIDE = 'R'\nTRANS = 'N':      Q * C          C * Q\nTRANS = 'C':      Q**H * C       C * Q**H\n\nIf VECT = 'P', ZUNMBR overwrites the general complex M-by-N matrix C\nwith\n                SIDE = 'L'     SIDE = 'R'\nTRANS = 'N':      P * C          C * P\nTRANS = 'C':      P**H * C       C * P**H\n\nHere Q and P**H are the unitary matrices determined by ZGEBRD when\nreducing a complex matrix A to bidiagonal form: A = Q * B * P**H. Q\nand P**H are defined as products of elementary reflectors H(i) and\nG(i) respectively.\n\nLet nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the\norder of the unitary matrix Q or P**H that is applied.\n\nIf VECT = 'Q', A is assumed to have been an NQ-by-K matrix:\nif nq >= k, Q = H(1) H(2) . . . H(k);\nif nq < k, Q = H(1) H(2) . . . H(nq-1).\n\nIf VECT = 'P', A is assumed to have been a K-by-NQ matrix:\nif k < nq, P = G(1) G(2) . . . G(k);\nif k >= nq, P = G(1) G(2) . . . G(nq-1)."), ('VECT', "VECT is CHARACTER*1\n= 'Q': apply Q or Q**H;\n= 'P': apply P or P**H."), ('SIDE', "SIDE is CHARACTER*1\n= 'L': apply Q, Q**H, P or P**H from the Left;\n= 'R': apply Q, Q**H, P or P**H from the Right."), ('TRANS', "TRANS is CHARACTER*1\n= 'N':  No transpose, apply Q or P;\n= 'C':  Conjugate transpose, apply Q**H or P**H."), ('M', 'M is INTEGER\nThe number of rows of the matrix C. M >= 0.'), ('N', 'N is INTEGER\nThe number of columns of the matrix C. N >= 0.'), ('K', "K is INTEGER\nIf VECT = 'Q', the number of columns in the original\nmatrix reduced by ZGEBRD.\nIf VECT = 'P', the number of rows in the original\nmatrix reduced by ZGEBRD.\nK >= 0."), ('A', "A is COMPLEX*16 array, dimension\n                      (LDA,min(nq,K)) if VECT = 'Q'\n                      (LDA,nq)        if VECT = 'P'\nThe vectors which define the elementary reflectors H(i) and\nG(i), whose products determine the matrices Q and P, as\nreturned by ZGEBRD."), ('LDA', "LDA is INTEGER\nThe leading dimension of the array A.\nIf VECT = 'Q', LDA >= max(1,nq);\nif VECT = 'P', LDA >= max(1,min(nq,K))."), ('TAU', 'TAU is COMPLEX*16 array, dimension (min(nq,K))\nTAU(i) must contain the scalar factor of the elementary\nreflector H(i) or G(i) which determines Q or P, as returned\nby ZGEBRD in the array argument TAUQ or TAUP.'), ('C', 'C is COMPLEX*16 array, dimension (LDC,N)\nOn entry, the M-by-N matrix C.\nOn exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q\nor P*C or P**H*C or C*P or C*P**H.'), ('LDC', 'LDC is INTEGER\nThe leading dimension of the array C. LDC >= max(1,M).'), ('WORK', 'WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))\nOn exit, if INFO = 0, WORK(1) returns the optimal LWORK.'), ('LWORK', "LWORK is INTEGER\nThe dimension of the array WORK.\nIf SIDE = 'L', LWORK >= max(1,N);\nif SIDE = 'R', LWORK >= max(1,M);\nif N = 0 or M = 0, LWORK >= 1.\nFor optimum performance LWORK >= max(1,N*NB) if SIDE = 'L',\nand LWORK >= max(1,M*NB) if SIDE = 'R', where NB is the\noptimal blocksize. (NB = 0 if M = 0 or N = 0.)\n\nIf LWORK = -1, then a workspace query is assumed; the routine\nonly calculates the optimal size of the WORK array, returns\nthis value as the first entry of the WORK array, and no error\nmessage related to LWORK is issued by XERBLA."), ('INFO', 'INFO is INTEGER\n= 0:  successful exit\n< 0:  if INFO = -i, the i-th argument had an illegal value'))
