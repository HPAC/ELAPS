(('dggevx', 'DGGEVX computes for a pair of N-by-N real nonsymmetric matrices (A,B)\nthe generalized eigenvalues, and optionally, the left and/or right\ngeneralized eigenvectors.\n\nOptionally also, it computes a balancing transformation to improve\nthe conditioning of the eigenvalues and eigenvectors (ILO, IHI,\nLSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for\nthe eigenvalues (RCONDE), and reciprocal condition numbers for the\nright eigenvectors (RCONDV).\n\nA generalized eigenvalue for a pair of matrices (A,B) is a scalar\nlambda or a ratio alpha/beta = lambda, such that A - lambda*B is\nsingular. It is usually represented as the pair (alpha,beta), as\nthere is a reasonable interpretation for beta=0, and even for both\nbeing zero.\n\nThe right eigenvector v(j) corresponding to the eigenvalue lambda(j)\nof (A,B) satisfies\n\n                 A * v(j) = lambda(j) * B * v(j) .\n\nThe left eigenvector u(j) corresponding to the eigenvalue lambda(j)\nof (A,B) satisfies\n\n                 u(j)**H * A  = lambda(j) * u(j)**H * B.\n\nwhere u(j)**H is the conjugate-transpose of u(j).'), ('BALANC', "BALANC is CHARACTER*1\nSpecifies the balance option to be performed.\n= 'N':  do not diagonally scale or permute;\n= 'P':  permute only;\n= 'S':  scale only;\n= 'B':  both permute and scale.\nComputed reciprocal condition numbers will be for the\nmatrices after permuting and/or balancing. Permuting does\nnot change condition numbers (in exact arithmetic), but\nbalancing does."), ('JOBVL', "JOBVL is CHARACTER*1\n= 'N':  do not compute the left generalized eigenvectors;\n= 'V':  compute the left generalized eigenvectors."), ('JOBVR', "JOBVR is CHARACTER*1\n= 'N':  do not compute the right generalized eigenvectors;\n= 'V':  compute the right generalized eigenvectors."), ('SENSE', "SENSE is CHARACTER*1\nDetermines which reciprocal condition numbers are computed.\n= 'N': none are computed;\n= 'E': computed for eigenvalues only;\n= 'V': computed for eigenvectors only;\n= 'B': computed for eigenvalues and eigenvectors."), ('N', 'N is INTEGER\nThe order of the matrices A, B, VL, and VR.  N >= 0.'), ('A', 'A is DOUBLE PRECISION array, dimension (LDA, N)\nOn entry, the matrix A in the pair (A,B).\nOn exit, A has been overwritten. If JOBVL=\'V\' or JOBVR=\'V\'\nor both, then A contains the first part of the real Schur\nform of the "balanced" versions of the input A and B.'), ('LDA', 'LDA is INTEGER\nThe leading dimension of A.  LDA >= max(1,N).'), ('B', 'B is DOUBLE PRECISION array, dimension (LDB, N)\nOn entry, the matrix B in the pair (A,B).\nOn exit, B has been overwritten. If JOBVL=\'V\' or JOBVR=\'V\'\nor both, then B contains the second part of the real Schur\nform of the "balanced" versions of the input A and B.'), ('LDB', 'LDB is INTEGER\nThe leading dimension of B.  LDB >= max(1,N).'), ('ALPHAR', 'ALPHAR is DOUBLE PRECISION array, dimension (N)'), ('ALPHAI', 'ALPHAI is DOUBLE PRECISION array, dimension (N)'), ('BETA', 'BETA is DOUBLE PRECISION array, dimension (N)\nOn exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will\nbe the generalized eigenvalues.  If ALPHAI(j) is zero, then\nthe j-th eigenvalue is real; if positive, then the j-th and\n(j+1)-st eigenvalues are a complex conjugate pair, with\nALPHAI(j+1) negative.\n\nNote: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)\nmay easily over- or underflow, and BETA(j) may even be zero.\nThus, the user should avoid naively computing the ratio\nALPHA/BETA. However, ALPHAR and ALPHAI will be always less\nthan and usually comparable with norm(A) in magnitude, and\nBETA always less than and usually comparable with norm(B).'), ('VL', "VL is DOUBLE PRECISION array, dimension (LDVL,N)\nIf JOBVL = 'V', the left eigenvectors u(j) are stored one\nafter another in the columns of VL, in the same order as\ntheir eigenvalues. If the j-th eigenvalue is real, then\nu(j) = VL(:,j), the j-th column of VL. If the j-th and\n(j+1)-th eigenvalues form a complex conjugate pair, then\nu(j) = VL(:,j)+i*VL(:,j+1) and u(j+1) = VL(:,j)-i*VL(:,j+1).\nEach eigenvector will be scaled so the largest component have\nabs(real part) + abs(imag. part) = 1.\nNot referenced if JOBVL = 'N'."), ('LDVL', "LDVL is INTEGER\nThe leading dimension of the matrix VL. LDVL >= 1, and\nif JOBVL = 'V', LDVL >= N."), ('VR', "VR is DOUBLE PRECISION array, dimension (LDVR,N)\nIf JOBVR = 'V', the right eigenvectors v(j) are stored one\nafter another in the columns of VR, in the same order as\ntheir eigenvalues. If the j-th eigenvalue is real, then\nv(j) = VR(:,j), the j-th column of VR. If the j-th and\n(j+1)-th eigenvalues form a complex conjugate pair, then\nv(j) = VR(:,j)+i*VR(:,j+1) and v(j+1) = VR(:,j)-i*VR(:,j+1).\nEach eigenvector will be scaled so the largest component have\nabs(real part) + abs(imag. part) = 1.\nNot referenced if JOBVR = 'N'."), ('LDVR', "LDVR is INTEGER\nThe leading dimension of the matrix VR. LDVR >= 1, and\nif JOBVR = 'V', LDVR >= N."), ('ILO', 'ILO is INTEGER'), ('IHI', "IHI is INTEGER\nILO and IHI are integer values such that on exit\nA(i,j) = 0 and B(i,j) = 0 if i > j and\nj = 1,...,ILO-1 or i = IHI+1,...,N.\nIf BALANC = 'N' or 'S', ILO = 1 and IHI = N."), ('LSCALE', 'LSCALE is DOUBLE PRECISION array, dimension (N)\nDetails of the permutations and scaling factors applied\nto the left side of A and B.  If PL(j) is the index of the\nrow interchanged with row j, and DL(j) is the scaling\nfactor applied to row j, then\n  LSCALE(j) = PL(j)  for j = 1,...,ILO-1\n            = DL(j)  for j = ILO,...,IHI\n            = PL(j)  for j = IHI+1,...,N.\nThe order in which the interchanges are made is N to IHI+1,\nthen 1 to ILO-1.'), ('RSCALE', 'RSCALE is DOUBLE PRECISION array, dimension (N)\nDetails of the permutations and scaling factors applied\nto the right side of A and B.  If PR(j) is the index of the\ncolumn interchanged with column j, and DR(j) is the scaling\nfactor applied to column j, then\n  RSCALE(j) = PR(j)  for j = 1,...,ILO-1\n            = DR(j)  for j = ILO,...,IHI\n            = PR(j)  for j = IHI+1,...,N\nThe order in which the interchanges are made is N to IHI+1,\nthen 1 to ILO-1.'), ('ABNRM', 'ABNRM is DOUBLE PRECISION\nThe one-norm of the balanced matrix A.'), ('BBNRM', 'BBNRM is DOUBLE PRECISION\nThe one-norm of the balanced matrix B.'), ('RCONDE', "RCONDE is DOUBLE PRECISION array, dimension (N)\nIf SENSE = 'E' or 'B', the reciprocal condition numbers of\nthe eigenvalues, stored in consecutive elements of the array.\nFor a complex conjugate pair of eigenvalues two consecutive\nelements of RCONDE are set to the same value. Thus RCONDE(j),\nRCONDV(j), and the j-th columns of VL and VR all correspond\nto the j-th eigenpair.\nIf SENSE = 'N or 'V', RCONDE is not referenced."), ('RCONDV', "RCONDV is DOUBLE PRECISION array, dimension (N)\nIf SENSE = 'V' or 'B', the estimated reciprocal condition\nnumbers of the eigenvectors, stored in consecutive elements\nof the array. For a complex eigenvector two consecutive\nelements of RCONDV are set to the same value. If the\neigenvalues cannot be reordered to compute RCONDV(j),\nRCONDV(j) is set to 0; this can only occur when the true\nvalue would be very small anyway.\nIf SENSE = 'N' or 'E', RCONDV is not referenced."), ('WORK', 'WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))\nOn exit, if INFO = 0, WORK(1) returns the optimal LWORK.'), ('LWORK', "LWORK is INTEGER\nThe dimension of the array WORK. LWORK >= max(1,2*N).\nIf BALANC = 'S' or 'B', or JOBVL = 'V', or JOBVR = 'V',\nLWORK >= max(1,6*N).\nIf SENSE = 'E' or 'B', LWORK >= max(1,10*N).\nIf SENSE = 'V' or 'B', LWORK >= 2*N*N+8*N+16.\n\nIf LWORK = -1, then a workspace query is assumed; the routine\nonly calculates the optimal size of the WORK array, returns\nthis value as the first entry of the WORK array, and no error\nmessage related to LWORK is issued by XERBLA."), ('IWORK', "IWORK is INTEGER array, dimension (N+6)\nIf SENSE = 'E', IWORK is not referenced."), ('BWORK', "BWORK is LOGICAL array, dimension (N)\nIf SENSE = 'N', BWORK is not referenced."), ('INFO', 'INFO is INTEGER\n= 0:  successful exit\n< 0:  if INFO = -i, the i-th argument had an illegal value.\n= 1,...,N:\n      The QZ iteration failed.  No eigenvectors have been\n      calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)\n      should be correct for j=INFO+1,...,N.\n> N:  =N+1: other than QZ iteration failed in DHGEQZ.\n      =N+2: error return from DTGEVC.'))
