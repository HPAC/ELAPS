(('claqr5', 'CLAQR5 called by CLAQR0 performs a\nsingle small-bulge multi-shift QR sweep.'), ('WANTT', 'WANTT is logical scalar\n   WANTT = .true. if the triangular Schur factor\n   is being computed.  WANTT is set to .false. otherwise.'), ('WANTZ', 'WANTZ is logical scalar\n   WANTZ = .true. if the unitary Schur factor is being\n   computed.  WANTZ is set to .false. otherwise.'), ('KACC22', 'KACC22 is integer with value 0, 1, or 2.\n   Specifies the computation mode of far-from-diagonal\n   orthogonal updates.\n0: CLAQR5 does not accumulate reflections and does not\n   use matrix-matrix multiply to update far-from-diagonal\n   matrix entries.\n1: CLAQR5 accumulates reflections and uses matrix-matrix\n   multiply to update the far-from-diagonal matrix entries.\n2: CLAQR5 accumulates reflections, uses matrix-matrix\n   multiply to update the far-from-diagonal matrix entries,\n   and takes advantage of 2-by-2 block structure during\n   matrix multiplies.'), ('N', 'N is integer scalar\n   N is the order of the Hessenberg matrix H upon which this\n   subroutine operates.'), ('KTOP', 'KTOP is integer scalar'), ('KBOT', 'KBOT is integer scalar\n   These are the first and last rows and columns of an\n   isolated diagonal block upon which the QR sweep is to be\n   applied. It is assumed without a check that\n             either KTOP = 1  or   H(KTOP,KTOP-1) = 0\n   and\n             either KBOT = N  or   H(KBOT+1,KBOT) = 0.'), ('NSHFTS', 'NSHFTS is integer scalar\n   NSHFTS gives the number of simultaneous shifts.  NSHFTS\n   must be positive and even.'), ('S', 'S is COMPLEX array of size (NSHFTS)\n   S contains the shifts of origin that define the multi-\n   shift QR sweep.  On output S may be reordered.'), ('H', 'H is COMPLEX array of size (LDH,N)\n   On input H contains a Hessenberg matrix.  On output a\n   multi-shift QR sweep with shifts SR(J)+i*SI(J) is applied\n   to the isolated diagonal block in rows and columns KTOP\n   through KBOT.'), ('LDH', 'LDH is integer scalar\n   LDH is the leading dimension of H just as declared in the\n   calling procedure.  LDH.GE.MAX(1,N).'), ('ILOZ', 'ILOZ is INTEGER'), ('IHIZ', 'IHIZ is INTEGER\n   Specify the rows of Z to which transformations must be\n   applied if WANTZ is .TRUE.. 1 .LE. ILOZ .LE. IHIZ .LE. N'), ('Z', 'Z is COMPLEX array of size (LDZ,IHI)\n   If WANTZ = .TRUE., then the QR Sweep unitary\n   similarity transformation is accumulated into\n   Z(ILOZ:IHIZ,ILO:IHI) from the right.\n   If WANTZ = .FALSE., then Z is unreferenced.'), ('LDZ', 'LDZ is integer scalar\n   LDA is the leading dimension of Z just as declared in\n   the calling procedure. LDZ.GE.N.'), ('V', 'V is COMPLEX array of size (LDV,NSHFTS/2)'), ('LDV', 'LDV is integer scalar\n   LDV is the leading dimension of V as declared in the\n   calling procedure.  LDV.GE.3.'), ('U', 'U is COMPLEX array of size\n   (LDU,3*NSHFTS-3)'), ('LDU', 'LDU is integer scalar\n   LDU is the leading dimension of U just as declared in the\n   in the calling subroutine.  LDU.GE.3*NSHFTS-3.'), ('NH', 'NH is integer scalar\n   NH is the number of columns in array WH available for\n   workspace. NH.GE.1.'), ('WH', 'WH is COMPLEX array of size (LDWH,NH)'), ('LDWH', 'LDWH is integer scalar\n   Leading dimension of WH just as declared in the\n   calling procedure.  LDWH.GE.3*NSHFTS-3.'), ('NV', 'NV is integer scalar\n   NV is the number of rows in WV agailable for workspace.\n   NV.GE.1.'), ('WV', 'WV is COMPLEX array of size\n   (LDWV,3*NSHFTS-3)'), ('LDWV', 'LDWV is integer scalar\n   LDWV is the leading dimension of WV as declared in the\n   in the calling subroutine.  LDWV.GE.NV.'))
