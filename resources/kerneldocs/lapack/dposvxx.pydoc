(('dposvxx', 'DPOSVXX uses the Cholesky factorization A = U**T*U or A = L*L**T\nto compute the solution to a double precision system of linear equations\nA * X = B, where A is an N-by-N symmetric positive definite matrix\nand X and B are N-by-NRHS matrices.\n\nIf requested, both normwise and maximum componentwise error bounds\nare returned. DPOSVXX will return a solution with a tiny\nguaranteed error (O(eps) where eps is the working machine\nprecision) unless the matrix is very ill-conditioned, in which\ncase a warning is returned. Relevant condition numbers also are\ncalculated and returned.\n\nDPOSVXX accepts user-provided factorizations and equilibration\nfactors; see the definitions of the FACT and EQUED options.\nSolving with refinement and using a factorization from a previous\nDPOSVXX call will also produce a solution with either O(eps)\nerrors or warnings, but we cannot make that claim for general\nuser-provided factorizations and equilibration factors if they\ndiffer from what DPOSVXX would itself produce.'), ('FACT', "FACT is CHARACTER*1\nfies whether or not the factored form of the matrix A is\nied on entry, and if not, whether the matrix A should be\nibrated before it is factored.\nF':  On entry, AF contains the factored form of A.\n     If EQUED is not 'N', the matrix A has been\n     equilibrated with scaling factors given by S.\n     A and AF are not modified.\nN':  The matrix A will be copied to AF and factored.\nE':  The matrix A will be equilibrated if necessary, then\n     copied to AF and factored."), ('UPLO', "UPLO is CHARACTER*1\nU':  Upper triangle of A is stored;\nL':  Lower triangle of A is stored."), ('N', 'N is INTEGER\number of linear equations, i.e., the order of the\nx A.  N >= 0.'), ('NRHS', 'NRHS is INTEGER\number of right hand sides, i.e., the number of columns\ne matrices B and X.  NRHS >= 0.'), ('A', "A is DOUBLE PRECISION array, dimension (LDA,N)\ntry, the symmetric matrix A, except if FACT = 'F' and EQUED =\nthen A must contain the equilibrated matrix\nS)*A*diag(S).  If UPLO = 'U', the leading N-by-N upper\ngular part of A contains the upper triangular part of the\nx A, and the strictly lower triangular part of A is not\nenced.  If UPLO = 'L', the leading N-by-N lower triangular\nof A contains the lower triangular part of the matrix A, and\ntrictly upper triangular part of A is not referenced.  A is\nodified if FACT = 'F' or 'N', or if FACT = 'E' and EQUED =\nn exit.\n\nit, if FACT = 'E' and EQUED = 'Y', A is overwritten by\nS)*A*diag(S)."), ('LDA', 'LDA is INTEGER\neading dimension of the array A.  LDA >= max(1,N).'), ('AF', "AF is DOUBLE PRECISION array, dimension (LDAF,N)\nCT = 'F', then AF is an input argument and on entry\nins the triangular factor U or L from the Cholesky\nrization A = U**T*U or A = L*L**T, in the same storage\nt as A.  If EQUED .ne. 'N', then AF is the factored\nof the equilibrated matrix diag(S)*A*diag(S).\n\nCT = 'N', then AF is an output argument and on exit\nns the triangular factor U or L from the Cholesky\nrization A = U**T*U or A = L*L**T of the original\nx A.\n\nCT = 'E', then AF is an output argument and on exit\nns the triangular factor U or L from the Cholesky\nrization A = U**T*U or A = L*L**T of the equilibrated\nx A (see the description of A for the form of the\nibrated matrix)."), ('LDAF', 'LDAF is INTEGER\neading dimension of the array AF.  LDAF >= max(1,N).'), ('EQUED', "EQUED is CHARACTER*1\nfies the form of equilibration that was done.\nN':  No equilibration (always true if FACT = 'N').\nY':  Both row and column equilibration, i.e., A has been\n     replaced by diag(S) * A * diag(S).\n is an input argument if FACT = 'F'; otherwise, it is an\nt argument."), ('S', "S is DOUBLE PRECISION array, dimension (N)\now scale factors for A.  If EQUED = 'Y', A is multiplied on\neft and right by diag(S).  S is an input argument if FACT =\notherwise, S is an output argument.  If FACT = 'F' and EQUED\n, each element of S must be positive.  If S is output, each\nnt of S is a power of the radix. If S is input, each element\nshould be a power of the radix to ensure a reliable solution\nrror estimates. Scaling by powers of the radix does not cause\ning errors unless the result underflows or overflows.\ning errors during scaling lead to refining with a matrix that\nt equivalent to the input matrix, producing error estimates\nmay not be reliable."), ('B', "B is DOUBLE PRECISION array, dimension (LDB,NRHS)\ntry, the N-by-NRHS right hand side matrix B.\nit,\nUED = 'N', B is not modified;\nUED = 'Y', B is overwritten by diag(S)*B;"), ('LDB', 'LDB is INTEGER\neading dimension of the array B.  LDB >= max(1,N).'), ('X', "X is DOUBLE PRECISION array, dimension (LDX,NRHS)\nFO = 0, the N-by-NRHS solution matrix X to the original\nm of equations.  Note that A and B are modified on exit if\n .ne. 'N', and the solution to the equilibrated system is\niag(S))*X."), ('LDX', 'LDX is INTEGER\neading dimension of the array X.  LDX >= max(1,N).'), ('RCOND', 'RCOND is DOUBLE PRECISION\nrocal scaled condition number.  This is an estimate of the\nrocal Skeel condition number of the matrix A after\nibration (if done).  If this is less than the machine\nsion (in particular, if it is zero), the matrix is singular\nrking precision.  Note that the error may still be small even\nis number is very small and the matrix appears ill-\ntioned.'), ('RPVGRW', 'RPVGRW is DOUBLE PRECISION\nrocal pivot growth.  On exit, this contains the reciprocal\n growth factor norm(A)/norm(U). The "max absolute element"\nis used.  If this is much less than 1, then the stability of\nU factorization of the (equilibrated) matrix A could be poor.\nalso means that the solution X, estimated condition numbers,\nrror bounds could be unreliable. If factorization fails with\nO<=N, then this contains the reciprocal pivot growth factor\nhe leading INFO columns of A.'), ('BERR', 'BERR is DOUBLE PRECISION array, dimension (NRHS)\nnentwise relative backward error.  This is the\nnentwise relative backward error of each solution vector X(j)\n, the smallest relative change in any element of A or B that\n X(j) an exact solution).'), ('N_ERR_BNDS', 'N_ERR_BNDS is INTEGER\nr of error bounds to return for each right hand side\nach type (normwise or componentwise).  See ERR_BNDS_NORM and\nNDS_COMP below.'), ('ERR_BNDS_NORM', 'ERR_BNDS_NORM is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\nach right-hand side, this array contains information about\nus error bounds and condition numbers corresponding to the\nise relative error, which is defined as follows:\n\nise relative error in the ith solution vector:\n   max_j (abs(XTRUE(j,i) - X(j,i)))\n  ------------------------------\n        max_j abs(X(j,i))\n\nrray is indexed by the type of error information as described\n. There currently are up to three pieces of information\nned.\n\nirst index in ERR_BNDS_NORM(i,:) corresponds to the ith\n-hand side.\n\necond index in ERR_BNDS_NORM(:,err) contains the following\n fields:\n 1 "Trust/don\'t trust" boolean. Trust the answer if the\n    reciprocal condition number is less than the threshold\n    sqrt(n) * dlamch(\'Epsilon\').\n\n 2 "Guaranteed" error bound: The estimated forward error,\n    almost certainly within a factor of 10 of the true error\n    so long as the next entry is greater than the threshold\n    sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n    be trusted if the previous boolean is true.\n\n 3  Reciprocal condition number: Estimated normwise\n    reciprocal condition number.  Compared with the threshold\n    sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n    estimate is "guaranteed". These reciprocal condition\n    numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n    appropriately scaled matrix Z.\n    Let Z = S*A, where S scales each row by a power of the\n    radix so all absolute row sums of Z are approximately 1.\n\napack Working Note 165 for further details and extra\nons.'), ('ERR_BNDS_COMP', 'ERR_BNDS_COMP is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\nach right-hand side, this array contains information about\nus error bounds and condition numbers corresponding to the\nnentwise relative error, which is defined as follows:\n\nnentwise relative error in the ith solution vector:\n          abs(XTRUE(j,i) - X(j,i))\n   max_j ----------------------\n               abs(X(j,i))\n\nrray is indexed by the right-hand side i (on which the\nnentwise relative error depends), and the type of error\nmation as described below. There currently are up to three\ns of information returned for each right-hand side. If\nnentwise accuracy is not requested (PARAMS(3) = 0.0), then\nNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\nirst (:,N_ERR_BNDS) entries are returned.\n\nirst index in ERR_BNDS_COMP(i,:) corresponds to the ith\n-hand side.\n\necond index in ERR_BNDS_COMP(:,err) contains the following\n fields:\n 1 "Trust/don\'t trust" boolean. Trust the answer if the\n    reciprocal condition number is less than the threshold\n    sqrt(n) * dlamch(\'Epsilon\').\n\n 2 "Guaranteed" error bound: The estimated forward error,\n    almost certainly within a factor of 10 of the true error\n    so long as the next entry is greater than the threshold\n    sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n    be trusted if the previous boolean is true.\n\n 3  Reciprocal condition number: Estimated componentwise\n    reciprocal condition number.  Compared with the threshold\n    sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n    estimate is "guaranteed". These reciprocal condition\n    numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n    appropriately scaled matrix Z.\n    Let Z = S*(A*diag(x)), where x is the solution for the\n    current right-hand side and S scales each row of\n    A*diag(x) by a power of the radix so all absolute row\n    sums of Z are approximately 1.\n\napack Working Note 165 for further details and extra\nons.'), ('NPARAMS', 'NPARAMS is INTEGER\nfies the number of parameters set in PARAMS.  If .LE. 0, the\nS array is never referenced and default values are used.'), ('PARAMS', 'PARAMS is DOUBLE PRECISION array, dimension NPARAMS\nfies algorithm parameters.  If an entry is .LT. 0.0, then\nentry will be filled with default value used for that\neter.  Only positions up to NPARAMS are accessed; defaults\nsed for higher-numbered parameters.\n\nAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n  refinement or not.\nefault: 1.0D+0\n  = 0.0 : No refinement is performed, and no error bounds are\n          computed.\n  = 1.0 : Use the extra-precise refinement algorithm.\n    (other values are reserved for future use)\n\nAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n  computations allowed for refinement.\nefault: 10\nggressive: Set to 100 to permit convergence using approximate\n           factorizations or factorizations other than LU. If\n           the factorization uses a technique other than\n           Gaussian elimination, the guarantees in\n           err_bnds_norm and err_bnds_comp may no longer be\n           trustworthy.\n\nAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n  will attempt to find a solution with small componentwise\n  relative error in the double-precision algorithm.  Positive\n  is true, 0.0 is false.\nefault: 1.0 (attempt componentwise convergence)'), ('WORK', 'WORK is DOUBLE PRECISION array, dimension (4*N)'), ('IWORK', 'IWORK is INTEGER array, dimension (N)'), ('INFO', 'INFO is INTEGER\n:  Successful exit. The solution to every right-hand side is\nuaranteed.\n:  If INFO = -i, the i-th argument had an illegal value\n and <= N:  U(INFO,INFO) is exactly zero.  The factorization\nas been completed, but the factor U is exactly singular, so\nhe solution and error bounds could not be computed. RCOND = 0\ns returned.\n+J: The solution corresponding to the Jth right-hand side is\not guaranteed. The solutions corresponding to other right-\nand sides K with K > J may not be guaranteed as well, but\nnly the first such right-hand side is reported. If a small\nomponentwise error is not requested (PARAMS(3) = 0.0) then\nhe Jth right-hand side is the first with a normwise error\nound that is not guaranteed (the smallest J such\nhat ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\nhe Jth right-hand side is the first with either a normwise or\nomponentwise error bound that is not guaranteed (the smallest\n such that either ERR_BNDS_NORM(J,1) = 0.0 or\nRR_BNDS_COMP(J,1) = 0.0). See the definition of\nRR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\nbout all of the right-hand sides check ERR_BNDS_NORM or\nRR_BNDS_COMP.'))
