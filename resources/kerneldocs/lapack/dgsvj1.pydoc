(('dgsvj1', "DGSVJ1 is called from SGESVJ as a pre-processor and that is its main\npurpose. It applies Jacobi rotations in the same way as SGESVJ does, but\nit targets only particular pivots and it does not check convergence\n(stopping criterion). Few tunning parameters (marked by [TP]) are\navailable for the implementer.\n\nFurther Details\n~~~~~~~~~~~~~~~\nDGSVJ1 applies few sweeps of Jacobi rotations in the column space of\nthe input M-by-N matrix A. The pivot pairs are taken from the (1,2)\noff-diagonal block in the corresponding N-by-N Gram matrix A^T * A. The\nblock-entries (tiles) of the (1,2) off-diagonal block are marked by the\n[x]'s in the following scheme:\n\n   | *  *  * [x] [x] [x]|\n   | *  *  * [x] [x] [x]|    Row-cycling in the nblr-by-nblc [x] blocks.\n   | *  *  * [x] [x] [x]|    Row-cyclic pivoting inside each [x] block.\n   |[x] [x] [x] *  *  * |\n   |[x] [x] [x] *  *  * |\n   |[x] [x] [x] *  *  * |\n\nIn terms of the columns of A, the first N1 columns are rotated 'against'\nthe remaining N-N1 columns, trying to increase the angle between the\ncorresponding subspaces. The off-diagonal block is N1-by(N-N1) and it is\ntiled using quadratic tiles of side KBL. Here, KBL is a tunning parmeter.\nThe number of sweeps is given in NSWEEP and the orthogonality threshold\nis given in TOL."), ('JOBV', "JOBV is CHARACTER*1\nSpecifies whether the output from this procedure is used\nto compute the matrix V:\n= 'V': the product of the Jacobi rotations is accumulated\n       by postmulyiplying the N-by-N array V.\n      (See the description of V.)\n= 'A': the product of the Jacobi rotations is accumulated\n       by postmulyiplying the MV-by-N array V.\n      (See the descriptions of MV and V.)\n= 'N': the Jacobi rotations are not accumulated."), ('M', 'M is INTEGER\nThe number of rows of the input matrix A.  M >= 0.'), ('N', 'N is INTEGER\nThe number of columns of the input matrix A.\nM >= N >= 0.'), ('N1', "N1 is INTEGER\nN1 specifies the 2 x 2 block partition, the first N1 columns are\nrotated 'against' the remaining N-N1 columns of A."), ('A', 'A is DOUBLE PRECISION array, dimension (LDA,N)\nOn entry, M-by-N matrix A, such that A*diag(D) represents\nthe input matrix.\nOn exit,\nA_onexit * D_onexit represents the input matrix A*diag(D)\npost-multiplied by a sequence of Jacobi rotations, where the\nrotation threshold and the total number of sweeps are given in\nTOL and NSWEEP, respectively.\n(See the descriptions of N1, D, TOL and NSWEEP.)'), ('LDA', 'LDA is INTEGER\nThe leading dimension of the array A.  LDA >= max(1,M).'), ('D', 'D is DOUBLE PRECISION array, dimension (N)\nThe array D accumulates the scaling factors from the fast scaled\nJacobi rotations.\nOn entry, A*diag(D) represents the input matrix.\nOn exit, A_onexit*diag(D_onexit) represents the input matrix\npost-multiplied by a sequence of Jacobi rotations, where the\nrotation threshold and the total number of sweeps are given in\nTOL and NSWEEP, respectively.\n(See the descriptions of N1, A, TOL and NSWEEP.)'), ('SVA', 'SVA is DOUBLE PRECISION array, dimension (N)\nOn entry, SVA contains the Euclidean norms of the columns of\nthe matrix A*diag(D).\nOn exit, SVA contains the Euclidean norms of the columns of\nthe matrix onexit*diag(D_onexit).'), ('MV', "MV is INTEGER\nIf JOBV .EQ. 'A', then MV rows of V are post-multipled by a\n                 sequence of Jacobi rotations.\nIf JOBV = 'N',   then MV is not referenced."), ('V', "V is DOUBLE PRECISION array, dimension (LDV,N)\nIf JOBV .EQ. 'V' then N rows of V are post-multipled by a\n                 sequence of Jacobi rotations.\nIf JOBV .EQ. 'A' then MV rows of V are post-multipled by a\n                 sequence of Jacobi rotations.\nIf JOBV = 'N',   then V is not referenced."), ('LDV', "LDV is INTEGER\nThe leading dimension of the array V,  LDV >= 1.\nIf JOBV = 'V', LDV .GE. N.\nIf JOBV = 'A', LDV .GE. MV."), ('EPS', "EPS is DOUBLE PRECISION\nEPS = DLAMCH('Epsilon')"), ('SFMIN', "SFMIN is DOUBLE PRECISION\nSFMIN = DLAMCH('Safe Minimum')"), ('TOL', 'TOL is DOUBLE PRECISION\nTOL is the threshold for Jacobi rotations. For a pair\nA(:,p), A(:,q) of pivot columns, the Jacobi rotation is\napplied only if DABS(COS(angle(A(:,p),A(:,q)))) .GT. TOL.'), ('NSWEEP', 'NSWEEP is INTEGER\nNSWEEP is the number of sweeps of Jacobi rotations to be\nperformed.'), ('WORK', 'WORK is DOUBLE PRECISION array, dimension (LWORK)'), ('LWORK', 'LWORK is INTEGER\nLWORK is the dimension of WORK. LWORK .GE. M.'), ('INFO', 'INFO is INTEGER\n= 0 : successful exit.\n< 0 : if INFO = -i, then the i-th argument had an illegal value'))
