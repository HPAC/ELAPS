(('dtgsen', 'DTGSEN reorders the generalized real Schur decomposition of a real\nmatrix pair (A, B) (in terms of an orthonormal equivalence trans-\nformation Q**T * (A, B) * Z), so that a selected cluster of eigenvalues\nappears in the leading diagonal blocks of the upper quasi-triangular\nmatrix A and the upper triangular B. The leading columns of Q and\nZ form orthonormal bases of the corresponding left and right eigen-\nspaces (deflating subspaces). (A, B) must be in generalized real\nSchur canonical form (as returned by DGGES), i.e. A is block upper\ntriangular with 1-by-1 and 2-by-2 diagonal blocks. B is upper\ntriangular.\n\nDTGSEN also computes the generalized eigenvalues\n\n            w(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)\n\nof the reordered matrix pair (A, B).\n\nOptionally, DTGSEN computes the estimates of reciprocal condition\nnumbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),\n(A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)\nbetween the matrix pairs (A11, B11) and (A22,B22) that correspond to\nthe selected cluster and the eigenvalues outside the cluster, resp.,\nand norms of "projections" onto left and right eigenspaces w.r.t.\nthe selected cluster in the (1,1)-block.'), ('IJOB', 'IJOB is INTEGER\nSpecifies whether condition numbers are required for the\ncluster of eigenvalues (PL and PR) or the deflating subspaces\n(Difu and Difl):\n =0: Only reorder w.r.t. SELECT. No extras.\n =1: Reciprocal of norms of "projections" onto left and right\n     eigenspaces w.r.t. the selected cluster (PL and PR).\n =2: Upper bounds on Difu and Difl. F-norm-based estimate\n     (DIF(1:2)).\n =3: Estimate of Difu and Difl. 1-norm-based estimate\n     (DIF(1:2)).\n     About 5 times as expensive as IJOB = 2.\n =4: Compute PL, PR and DIF (i.e. 0, 1 and 2 above): Economic\n     version to get it all.\n =5: Compute PL, PR and DIF (i.e. 0, 1 and 3 above)'), ('WANTQ', 'WANTQ is LOGICAL\n.TRUE. : update the left transformation matrix Q;\n.FALSE.: do not update Q.'), ('WANTZ', 'WANTZ is LOGICAL\n.TRUE. : update the right transformation matrix Z;\n.FALSE.: do not update Z.'), ('SELECT', 'SELECT is LOGICAL array, dimension (N)\nSELECT specifies the eigenvalues in the selected cluster.\nTo select a real eigenvalue w(j), SELECT(j) must be set to\n.TRUE.. To select a complex conjugate pair of eigenvalues\nw(j) and w(j+1), corresponding to a 2-by-2 diagonal block,\neither SELECT(j) or SELECT(j+1) or both must be set to\n.TRUE.; a complex conjugate pair of eigenvalues must be\neither both included in the cluster or both excluded.'), ('N', 'N is INTEGER\nThe order of the matrices A and B. N >= 0.'), ('A', 'A is DOUBLE PRECISION array, dimension(LDA,N)\nOn entry, the upper quasi-triangular matrix A, with (A, B) in\ngeneralized real Schur canonical form.\nOn exit, A is overwritten by the reordered matrix A.'), ('LDA', 'LDA is INTEGER\nThe leading dimension of the array A. LDA >= max(1,N).'), ('B', 'B is DOUBLE PRECISION array, dimension(LDB,N)\nOn entry, the upper triangular matrix B, with (A, B) in\ngeneralized real Schur canonical form.\nOn exit, B is overwritten by the reordered matrix B.'), ('LDB', 'LDB is INTEGER\nThe leading dimension of the array B. LDB >= max(1,N).'), ('ALPHAR', 'ALPHAR is DOUBLE PRECISION array, dimension (N)'), ('ALPHAI', 'ALPHAI is DOUBLE PRECISION array, dimension (N)'), ('BETA', 'BETA is DOUBLE PRECISION array, dimension (N)\n\nOn exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will\nbe the generalized eigenvalues.  ALPHAR(j) + ALPHAI(j)*i\nand BETA(j),j=1,...,N  are the diagonals of the complex Schur\nform (S,T) that would result if the 2-by-2 diagonal blocks of\nthe real generalized Schur form of (A,B) were further reduced\nto triangular form using complex unitary transformations.\nIf ALPHAI(j) is zero, then the j-th eigenvalue is real; if\npositive, then the j-th and (j+1)-st eigenvalues are a\ncomplex conjugate pair, with ALPHAI(j+1) negative.'), ('Q', 'Q is DOUBLE PRECISION array, dimension (LDQ,N)\nOn entry, if WANTQ = .TRUE., Q is an N-by-N matrix.\nOn exit, Q has been postmultiplied by the left orthogonal\ntransformation matrix which reorder (A, B); The leading M\ncolumns of Q form orthonormal bases for the specified pair of\nleft eigenspaces (deflating subspaces).\nIf WANTQ = .FALSE., Q is not referenced.'), ('LDQ', 'LDQ is INTEGER\nThe leading dimension of the array Q.  LDQ >= 1;\nand if WANTQ = .TRUE., LDQ >= N.'), ('Z', 'Z is DOUBLE PRECISION array, dimension (LDZ,N)\nOn entry, if WANTZ = .TRUE., Z is an N-by-N matrix.\nOn exit, Z has been postmultiplied by the left orthogonal\ntransformation matrix which reorder (A, B); The leading M\ncolumns of Z form orthonormal bases for the specified pair of\nleft eigenspaces (deflating subspaces).\nIf WANTZ = .FALSE., Z is not referenced.'), ('LDZ', 'LDZ is INTEGER\nThe leading dimension of the array Z. LDZ >= 1;\nIf WANTZ = .TRUE., LDZ >= N.'), ('M', 'M is INTEGER\nThe dimension of the specified pair of left and right eigen-\nspaces (deflating subspaces). 0 <= M <= N.'), ('PL', 'PL is DOUBLE PRECISION'), ('PR', 'PR is DOUBLE PRECISION\n\nIf IJOB = 1, 4 or 5, PL, PR are lower bounds on the\nreciprocal of the norm of "projections" onto left and right\neigenspaces with respect to the selected cluster.\n0 < PL, PR <= 1.\nIf M = 0 or M = N, PL = PR  = 1.\nIf IJOB = 0, 2 or 3, PL and PR are not referenced.'), ('DIF', 'DIF is DOUBLE PRECISION array, dimension (2).\nIf IJOB >= 2, DIF(1:2) store the estimates of Difu and Difl.\nIf IJOB = 2 or 4, DIF(1:2) are F-norm-based upper bounds on\nDifu and Difl. If IJOB = 3 or 5, DIF(1:2) are 1-norm-based\nestimates of Difu and Difl.\nIf M = 0 or N, DIF(1:2) = F-norm([A, B]).\nIf IJOB = 0 or 1, DIF is not referenced.'), ('WORK', 'WORK is DOUBLE PRECISION array,\ndimension (MAX(1,LWORK)) \nOn exit, if INFO = 0, WORK(1) returns the optimal LWORK.'), ('LWORK', 'LWORK is INTEGER\nThe dimension of the array WORK. LWORK >=  4*N+16.\nIf IJOB = 1, 2 or 4, LWORK >= MAX(4*N+16, 2*M*(N-M)).\nIf IJOB = 3 or 5, LWORK >= MAX(4*N+16, 4*M*(N-M)).\n\nIf LWORK = -1, then a workspace query is assumed; the routine\nonly calculates the optimal size of the WORK array, returns\nthis value as the first entry of the WORK array, and no error\nmessage related to LWORK is issued by XERBLA.'), ('IWORK', 'IWORK is INTEGER array, dimension (MAX(1,LIWORK))\nOn exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.'), ('LIWORK', 'LIWORK is INTEGER\nThe dimension of the array IWORK. LIWORK >= 1.\nIf IJOB = 1, 2 or 4, LIWORK >=  N+6.\nIf IJOB = 3 or 5, LIWORK >= MAX(2*M*(N-M), N+6).\n\nIf LIWORK = -1, then a workspace query is assumed; the\nroutine only calculates the optimal size of the IWORK array,\nreturns this value as the first entry of the IWORK array, and\nno error message related to LIWORK is issued by XERBLA.'), ('INFO', 'INFO is INTEGER\n  =0: Successful exit.\n  <0: If INFO = -i, the i-th argument had an illegal value.\n  =1: Reordering of (A, B) failed because the transformed\n      matrix pair (A, B) would be too far from generalized\n      Schur form; the problem is very ill-conditioned.\n      (A, B) may have been partially reordered.\n      If requested, 0 is returned in DIF(*), PL and PR.'))
