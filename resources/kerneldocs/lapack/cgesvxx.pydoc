(('cgesvxx', 'CGESVXX uses the LU factorization to compute the solution to a\ncomplex system of linear equations  A * X = B,  where A is an\nN-by-N matrix and X and B are N-by-NRHS matrices.\n\nIf requested, both normwise and maximum componentwise error bounds\nare returned. CGESVXX will return a solution with a tiny\nguaranteed error (O(eps) where eps is the working machine\nprecision) unless the matrix is very ill-conditioned, in which\ncase a warning is returned. Relevant condition numbers also are\ncalculated and returned.\n\nCGESVXX accepts user-provided factorizations and equilibration\nfactors; see the definitions of the FACT and EQUED options.\nSolving with refinement and using a factorization from a previous\nCGESVXX call will also produce a solution with either O(eps)\nerrors or warnings, but we cannot make that claim for general\nuser-provided factorizations and equilibration factors if they\ndiffer from what CGESVXX would itself produce.'), ('FACT', "FACT is CHARACTER*1\nfies whether or not the factored form of the matrix A is\nied on entry, and if not, whether the matrix A should be\nibrated before it is factored.\nF':  On entry, AF and IPIV contain the factored form of A.\n     If EQUED is not 'N', the matrix A has been\n     equilibrated with scaling factors given by R and C.\n     A, AF, and IPIV are not modified.\nN':  The matrix A will be copied to AF and factored.\nE':  The matrix A will be equilibrated if necessary, then\n     copied to AF and factored."), ('TRANS', "TRANS is CHARACTER*1\nfies the form of the system of equations:\nN':  A * X = B     (No transpose)\nT':  A**T * X = B  (Transpose)\nC':  A**H * X = B  (Conjugate Transpose)"), ('N', 'N is INTEGER\number of linear equations, i.e., the order of the\nx A.  N >= 0.'), ('NRHS', 'NRHS is INTEGER\number of right hand sides, i.e., the number of columns\ne matrices B and X.  NRHS >= 0.'), ('A', "A is COMPLEX array, dimension (LDA,N)\ntry, the N-by-N matrix A.  If FACT = 'F' and EQUED is\nN', then A must have been equilibrated by the scaling\nrs in R and/or C.  A is not modified if FACT = 'F' or\nor if FACT = 'E' and EQUED = 'N' on exit.\n\nit, if EQUED .ne. 'N', A is scaled as follows:\n = 'R':  A := diag(R) * A\n = 'C':  A := A * diag(C)\n = 'B':  A := diag(R) * A * diag(C)."), ('LDA', 'LDA is INTEGER\neading dimension of the array A.  LDA >= max(1,N).'), ('AF', "AF is COMPLEX array, dimension (LDAF,N)\nCT = 'F', then AF is an input argument and on entry\nins the factors L and U from the factorization\n*L*U as computed by CGETRF.  If EQUED .ne. 'N', then\n the factored form of the equilibrated matrix A.\n\nCT = 'N', then AF is an output argument and on exit\nns the factors L and U from the factorization A = P*L*U\ne original matrix A.\n\nCT = 'E', then AF is an output argument and on exit\nns the factors L and U from the factorization A = P*L*U\ne equilibrated matrix A (see the description of A for\norm of the equilibrated matrix)."), ('LDAF', 'LDAF is INTEGER\neading dimension of the array AF.  LDAF >= max(1,N).'), ('IPIV', "IPIV is INTEGER array, dimension (N)\nCT = 'F', then IPIV is an input argument and on entry\nins the pivot indices from the factorization A = P*L*U\nmputed by CGETRF; row i of the matrix was interchanged\nrow IPIV(i).\n\nCT = 'N', then IPIV is an output argument and on exit\nins the pivot indices from the factorization A = P*L*U\ne original matrix A.\n\nCT = 'E', then IPIV is an output argument and on exit\nins the pivot indices from the factorization A = P*L*U\ne equilibrated matrix A."), ('EQUED', "EQUED is CHARACTER*1\nfies the form of equilibration that was done.\nN':  No equilibration (always true if FACT = 'N').\nR':  Row equilibration, i.e., A has been premultiplied by\n     diag(R).\nC':  Column equilibration, i.e., A has been postmultiplied\n     by diag(C).\nB':  Both row and column equilibration, i.e., A has been\n     replaced by diag(R) * A * diag(C).\n is an input argument if FACT = 'F'; otherwise, it is an\nt argument."), ('R', "R is REAL array, dimension (N)\now scale factors for A.  If EQUED = 'R' or 'B', A is\nplied on the left by diag(R); if EQUED = 'N' or 'C', R\nt accessed.  R is an input argument if FACT = 'F';\nwise, R is an output argument.  If FACT = 'F' and\n = 'R' or 'B', each element of R must be positive.\nis output, each element of R is a power of the radix.\nis input, each element of R should be a power of the radix\nsure a reliable solution and error estimates. Scaling by\ns of the radix does not cause rounding errors unless the\nt underflows or overflows. Rounding errors during scaling\nto refining with a matrix that is not equivalent to the\n matrix, producing error estimates that may not be\nble."), ('C', "C is REAL array, dimension (N)\nolumn scale factors for A.  If EQUED = 'C' or 'B', A is\nplied on the right by diag(C); if EQUED = 'N' or 'R', C\nt accessed.  C is an input argument if FACT = 'F';\nwise, C is an output argument.  If FACT = 'F' and\n = 'C' or 'B', each element of C must be positive.\nis output, each element of C is a power of the radix.\nis input, each element of C should be a power of the radix\nsure a reliable solution and error estimates. Scaling by\ns of the radix does not cause rounding errors unless the\nt underflows or overflows. Rounding errors during scaling\nto refining with a matrix that is not equivalent to the\n matrix, producing error estimates that may not be\nble."), ('B', "B is COMPLEX array, dimension (LDB,NRHS)\ntry, the N-by-NRHS right hand side matrix B.\nit,\nUED = 'N', B is not modified;\nANS = 'N' and EQUED = 'R' or 'B', B is overwritten by\nag(R)*B;\nANS = 'T' or 'C' and EQUED = 'C' or 'B', B is\nerwritten by diag(C)*B."), ('LDB', 'LDB is INTEGER\neading dimension of the array B.  LDB >= max(1,N).'), ('X', "X is COMPLEX array, dimension (LDX,NRHS)\nFO = 0, the N-by-NRHS solution matrix X to the original\nm of equations.  Note that A and B are modified on exit\nUED .ne. 'N', and the solution to the equilibrated system is\niag(C))*X if TRANS = 'N' and EQUED = 'C' or 'B', or\niag(R))*X if TRANS = 'T' or 'C' and EQUED = 'R' or 'B'."), ('LDX', 'LDX is INTEGER\neading dimension of the array X.  LDX >= max(1,N).'), ('RCOND', 'RCOND is REAL\nrocal scaled condition number.  This is an estimate of the\nrocal Skeel condition number of the matrix A after\nibration (if done).  If this is less than the machine\nsion (in particular, if it is zero), the matrix is singular\nrking precision.  Note that the error may still be small even\nis number is very small and the matrix appears ill-\ntioned.'), ('RPVGRW', 'RPVGRW is REAL\nrocal pivot growth.  On exit, this contains the reciprocal\n growth factor norm(A)/norm(U). The "max absolute element"\nis used.  If this is much less than 1, then the stability of\nU factorization of the (equilibrated) matrix A could be poor.\nalso means that the solution X, estimated condition numbers,\nrror bounds could be unreliable. If factorization fails with\nO<=N, then this contains the reciprocal pivot growth factor\nhe leading INFO columns of A.  In CGESVX, this quantity is\nned in WORK(1).'), ('BERR', 'BERR is REAL array, dimension (NRHS)\nnentwise relative backward error.  This is the\nnentwise relative backward error of each solution vector X(j)\n, the smallest relative change in any element of A or B that\n X(j) an exact solution).'), ('N_ERR_BNDS', 'N_ERR_BNDS is INTEGER\nr of error bounds to return for each right hand side\nach type (normwise or componentwise).  See ERR_BNDS_NORM and\nNDS_COMP below.'), ('ERR_BNDS_NORM', 'ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)\nach right-hand side, this array contains information about\nus error bounds and condition numbers corresponding to the\nise relative error, which is defined as follows:\n\nise relative error in the ith solution vector:\n   max_j (abs(XTRUE(j,i) - X(j,i)))\n  ------------------------------\n        max_j abs(X(j,i))\n\nrray is indexed by the type of error information as described\n. There currently are up to three pieces of information\nned.\n\nirst index in ERR_BNDS_NORM(i,:) corresponds to the ith\n-hand side.\n\necond index in ERR_BNDS_NORM(:,err) contains the following\n fields:\n 1 "Trust/don\'t trust" boolean. Trust the answer if the\n    reciprocal condition number is less than the threshold\n    sqrt(n) * slamch(\'Epsilon\').\n\n 2 "Guaranteed" error bound: The estimated forward error,\n    almost certainly within a factor of 10 of the true error\n    so long as the next entry is greater than the threshold\n    sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n    be trusted if the previous boolean is true.\n\n 3  Reciprocal condition number: Estimated normwise\n    reciprocal condition number.  Compared with the threshold\n    sqrt(n) * slamch(\'Epsilon\') to determine if the error\n    estimate is "guaranteed". These reciprocal condition\n    numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n    appropriately scaled matrix Z.\n    Let Z = S*A, where S scales each row by a power of the\n    radix so all absolute row sums of Z are approximately 1.\n\napack Working Note 165 for further details and extra\nons.'), ('ERR_BNDS_COMP', 'ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS)\nach right-hand side, this array contains information about\nus error bounds and condition numbers corresponding to the\nnentwise relative error, which is defined as follows:\n\nnentwise relative error in the ith solution vector:\n          abs(XTRUE(j,i) - X(j,i))\n   max_j ----------------------\n               abs(X(j,i))\n\nrray is indexed by the right-hand side i (on which the\nnentwise relative error depends), and the type of error\nmation as described below. There currently are up to three\ns of information returned for each right-hand side. If\nnentwise accuracy is not requested (PARAMS(3) = 0.0), then\nNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\nirst (:,N_ERR_BNDS) entries are returned.\n\nirst index in ERR_BNDS_COMP(i,:) corresponds to the ith\n-hand side.\n\necond index in ERR_BNDS_COMP(:,err) contains the following\n fields:\n 1 "Trust/don\'t trust" boolean. Trust the answer if the\n    reciprocal condition number is less than the threshold\n    sqrt(n) * slamch(\'Epsilon\').\n\n 2 "Guaranteed" error bound: The estimated forward error,\n    almost certainly within a factor of 10 of the true error\n    so long as the next entry is greater than the threshold\n    sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n    be trusted if the previous boolean is true.\n\n 3  Reciprocal condition number: Estimated componentwise\n    reciprocal condition number.  Compared with the threshold\n    sqrt(n) * slamch(\'Epsilon\') to determine if the error\n    estimate is "guaranteed". These reciprocal condition\n    numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n    appropriately scaled matrix Z.\n    Let Z = S*(A*diag(x)), where x is the solution for the\n    current right-hand side and S scales each row of\n    A*diag(x) by a power of the radix so all absolute row\n    sums of Z are approximately 1.\n\napack Working Note 165 for further details and extra\nons.'), ('NPARAMS', 'NPARAMS is INTEGER\nfies the number of parameters set in PARAMS.  If .LE. 0, the\nS array is never referenced and default values are used.'), ('PARAMS', 'PARAMS is REAL array, dimension NPARAMS\nfies algorithm parameters.  If an entry is .LT. 0.0, then\nentry will be filled with default value used for that\neter.  Only positions up to NPARAMS are accessed; defaults\nsed for higher-numbered parameters.\n\nAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n  refinement or not.\nefault: 1.0\n  = 0.0 : No refinement is performed, and no error bounds are\n          computed.\n  = 1.0 : Use the double-precision refinement algorithm,\n          possibly with doubled-single computations if the\n          compilation environment does not support DOUBLE\n          PRECISION.\n    (other values are reserved for future use)\n\nAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n  computations allowed for refinement.\nefault: 10\nggressive: Set to 100 to permit convergence using approximate\n           factorizations or factorizations other than LU. If\n           the factorization uses a technique other than\n           Gaussian elimination, the guarantees in\n           err_bnds_norm and err_bnds_comp may no longer be\n           trustworthy.\n\nAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n  will attempt to find a solution with small componentwise\n  relative error in the double-precision algorithm.  Positive\n  is true, 0.0 is false.\nefault: 1.0 (attempt componentwise convergence)'), ('WORK', 'WORK is COMPLEX array, dimension (2*N)'), ('RWORK', 'RWORK is REAL array, dimension (2*N)'), ('INFO', 'INFO is INTEGER\n:  Successful exit. The solution to every right-hand side is\nuaranteed.\n:  If INFO = -i, the i-th argument had an illegal value\n and <= N:  U(INFO,INFO) is exactly zero.  The factorization\nas been completed, but the factor U is exactly singular, so\nhe solution and error bounds could not be computed. RCOND = 0\ns returned.\n+J: The solution corresponding to the Jth right-hand side is\not guaranteed. The solutions corresponding to other right-\nand sides K with K > J may not be guaranteed as well, but\nnly the first such right-hand side is reported. If a small\nomponentwise error is not requested (PARAMS(3) = 0.0) then\nhe Jth right-hand side is the first with a normwise error\nound that is not guaranteed (the smallest J such\nhat ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\nhe Jth right-hand side is the first with either a normwise or\nomponentwise error bound that is not guaranteed (the smallest\n such that either ERR_BNDS_NORM(J,1) = 0.0 or\nRR_BNDS_COMP(J,1) = 0.0). See the definition of\nRR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\nbout all of the right-hand sides check ERR_BNDS_NORM or\nRR_BNDS_COMP.'))
