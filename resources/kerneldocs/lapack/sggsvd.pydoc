(('sggsvd', 'SGGSVD computes the generalized singular value decomposition (GSVD)\nof an M-by-N real matrix A and P-by-N real matrix B:\n\n      U**T*A*Q = D1*( 0 R ),    V**T*B*Q = D2*( 0 R )\n\nwhere U, V and Q are orthogonal matrices.\nLet K+L = the effective numerical rank of the matrix (A**T,B**T)**T,\nthen R is a K+L-by-K+L nonsingular upper triangular matrix, D1 and\nD2 are M-by-(K+L) and P-by-(K+L) "diagonal" matrices and of the\nfollowing structures, respectively:\n\nIf M-K-L >= 0,\n\n                    K  L\n       D1 =     K ( I  0 )\n                L ( 0  C )\n            M-K-L ( 0  0 )\n\n                  K  L\n       D2 =   L ( 0  S )\n            P-L ( 0  0 )\n\n                N-K-L  K    L\n  ( 0 R ) = K (  0   R11  R12 )\n            L (  0    0   R22 )\n\nwhere\n\n  C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),\n  S = diag( BETA(K+1),  ... , BETA(K+L) ),\n  C**2 + S**2 = I.\n\n  R is stored in A(1:K+L,N-K-L+1:N) on exit.\n\nIf M-K-L < 0,\n\n                  K M-K K+L-M\n       D1 =   K ( I  0    0   )\n            M-K ( 0  C    0   )\n\n                    K M-K K+L-M\n       D2 =   M-K ( 0  S    0  )\n            K+L-M ( 0  0    I  )\n              P-L ( 0  0    0  )\n\n                   N-K-L  K   M-K  K+L-M\n  ( 0 R ) =     K ( 0    R11  R12  R13  )\n              M-K ( 0     0   R22  R23  )\n            K+L-M ( 0     0    0   R33  )\n\nwhere\n\n  C = diag( ALPHA(K+1), ... , ALPHA(M) ),\n  S = diag( BETA(K+1),  ... , BETA(M) ),\n  C**2 + S**2 = I.\n\n  (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored\n  ( 0  R22 R23 )\n  in B(M-K+1:L,N+M-K-L+1:N) on exit.\n\nThe routine computes C, S, R, and optionally the orthogonal\ntransformation matrices U, V and Q.\n\nIn particular, if B is an N-by-N nonsingular matrix, then the GSVD of\nA and B implicitly gives the SVD of A*inv(B):\n                     A*inv(B) = U*(D1*inv(D2))*V**T.\nIf ( A**T,B**T)**T  has orthonormal columns, then the GSVD of A and B is\nalso equal to the CS decomposition of A and B. Furthermore, the GSVD\ncan be used to derive the solution of the eigenvalue problem:\n                     A**T*A x = lambda* B**T*B x.\nIn some literature, the GSVD of A and B is presented in the form\n                 U**T*A*X = ( 0 D1 ),   V**T*B*X = ( 0 D2 )\nwhere U and V are orthogonal and X is nonsingular, D1 and D2 are\n``diagonal\'\'.  The former GSVD form can be converted to the latter\nform by taking the nonsingular matrix X as\n\n                     X = Q*( I   0    )\n                           ( 0 inv(R) ).'), ('JOBU', "JOBU is CHARACTER*1\n= 'U':  Orthogonal matrix U is computed;\n= 'N':  U is not computed."), ('JOBV', "JOBV is CHARACTER*1\n= 'V':  Orthogonal matrix V is computed;\n= 'N':  V is not computed."), ('JOBQ', "JOBQ is CHARACTER*1\n= 'Q':  Orthogonal matrix Q is computed;\n= 'N':  Q is not computed."), ('M', 'M is INTEGER\nThe number of rows of the matrix A.  M >= 0.'), ('N', 'N is INTEGER\nThe number of columns of the matrices A and B.  N >= 0.'), ('P', 'P is INTEGER\nThe number of rows of the matrix B.  P >= 0.'), ('K', 'K is INTEGER'), ('L', 'L is INTEGER\n\nOn exit, K and L specify the dimension of the subblocks\ndescribed in Purpose.\nK + L = effective numerical rank of (A**T,B**T)**T.'), ('A', 'A is REAL array, dimension (LDA,N)\nOn entry, the M-by-N matrix A.\nOn exit, A contains the triangular matrix R, or part of R.\nSee Purpose for details.'), ('LDA', 'LDA is INTEGER\nThe leading dimension of the array A. LDA >= max(1,M).'), ('B', 'B is REAL array, dimension (LDB,N)\nOn entry, the P-by-N matrix B.\nOn exit, B contains the triangular matrix R if M-K-L < 0.\nSee Purpose for details.'), ('LDB', 'LDB is INTEGER\nThe leading dimension of the array B. LDB >= max(1,P).'), ('ALPHA', 'ALPHA is REAL array, dimension (N)'), ('BETA', 'BETA is REAL array, dimension (N)\n\nOn exit, ALPHA and BETA contain the generalized singular\nvalue pairs of A and B;\n  ALPHA(1:K) = 1,\n  BETA(1:K)  = 0,\nand if M-K-L >= 0,\n  ALPHA(K+1:K+L) = C,\n  BETA(K+1:K+L)  = S,\nor if M-K-L < 0,\n  ALPHA(K+1:M)=C, ALPHA(M+1:K+L)=0\n  BETA(K+1:M) =S, BETA(M+1:K+L) =1\nand\n  ALPHA(K+L+1:N) = 0\n  BETA(K+L+1:N)  = 0'), ('U', "U is REAL array, dimension (LDU,M)\nIf JOBU = 'U', U contains the M-by-M orthogonal matrix U.\nIf JOBU = 'N', U is not referenced."), ('LDU', "LDU is INTEGER\nThe leading dimension of the array U. LDU >= max(1,M) if\nJOBU = 'U'; LDU >= 1 otherwise."), ('V', "V is REAL array, dimension (LDV,P)\nIf JOBV = 'V', V contains the P-by-P orthogonal matrix V.\nIf JOBV = 'N', V is not referenced."), ('LDV', "LDV is INTEGER\nThe leading dimension of the array V. LDV >= max(1,P) if\nJOBV = 'V'; LDV >= 1 otherwise."), ('Q', "Q is REAL array, dimension (LDQ,N)\nIf JOBQ = 'Q', Q contains the N-by-N orthogonal matrix Q.\nIf JOBQ = 'N', Q is not referenced."), ('LDQ', "LDQ is INTEGER\nThe leading dimension of the array Q. LDQ >= max(1,N) if\nJOBQ = 'Q'; LDQ >= 1 otherwise."), ('WORK', 'WORK is REAL array,\n            dimension (max(3*N,M,P)+N)'), ('IWORK', 'IWORK is INTEGER array, dimension (N)\nOn exit, IWORK stores the sorting information. More\nprecisely, the following loop will sort ALPHA\n   for I = K+1, min(M,K+L)\n       swap ALPHA(I) and ALPHA(IWORK(I))\n   endfor\nsuch that ALPHA(1) >= ALPHA(2) >= ... >= ALPHA(N).'), ('INFO', 'INFO is INTEGER\n= 0:  successful exit\n< 0:  if INFO = -i, the i-th argument had an illegal value.\n> 0:  if INFO = 1, the Jacobi-type procedure failed to\n      converge.  For further details, see subroutine STGSJA.'))
